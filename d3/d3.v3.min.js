! function () {função n (n) {return n && (n.ownerDocument || n.document || n) .documentElement} função t (n) {return n && (n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView)} function e (n, t) {retorno t> n? -1: n> t? 1: n> = t? 0: NaN} função r (n) {retorno nulo === n NaN: + n} função i (n) {retorno! IsNaN (n)} função u (n) {retorno {esquerda: função (t, e, r, i) {para (argumentos.length <3 && (r = 0), arguments.length <4 && (i = t.length); i> r;) {var u = r + i >>> 1; n (t [u], e) <0? R = u + 1 : i = u} retorna r}, direita: function (t, e, r, i) {para (arguments.length <3 && (r = 0), arguments.length <4 && (i = t.length); i> r;) {var u = r + i >>> 1; n (t [u], e)> 0? i = u: r = u + 1} retorno r}}} funcao o (n) {retorno n função .length} a (n) {para (var t = 1; n * t% 1;) t * = 10; retorno t} função l (n, t) {para (var e em t) Object.defineProperty ( n.prototipo, e,{value: t [e], enumerável:! 1})} função c () {this ._ = Object.create (null)} função f (n) {return (n + = "") === bo || n [0] === _o? _o + n: n} função s (n) {retorno (n + = "") [0] === _o? n.slice (1): n} função h (n) {return f (n) nesta função ._} p (n) {return (n = f (n)) neste ._ && delete this ._ [n]} function g () {var n = []; var t neste ._) n.push (s (t)); retorno n} função v () {var n = 0; para (var t neste ._) ++ n; retorno n} função d () {para (var n neste ._) retornar! 1; retornar! 0} função y () {this ._ = Object.create (null)} função m (n) {retornar n} função M (n, t, e) {função return () {var r = e.apply (t, argumentos); retorno r === t? n: r}} função x (n, t) {se (t em n) retorna t; = t.charAt (0) .toUpperCase () + t.slice (1); para (var e = 0, r = comprimento w; r> e; ++ e) {var i = wo [e] + t ; if (i em n) retorna i}} funç˜ao b () {} funç˜ao _ () {} funç˜ao w (n) {funç˜ao t () {para (var t, r = e, i = -1, u = r.length; ++ i <u;) (t = r [i] .on) &&t.apply (this, arguments); return n} var e = [], r = new c; retorno t.on = função (t, i) {var u, o = r.get (t); argumentos de retorno. length <2? o && o.on: (o && (o.on = null, e = e.slice (0, u = e.indexOf (o)). concat (e.slice (u + 1)), r.remove (t)), i && e.push (r.set (t, {on: i})), n)}, t} função S () {ao.event.preventDefault ()} função k () {para (var n, t = ao.evento; n = t.sourceEvent;) t = n; retorno t} função N (n) {para (var t = novo _, e = 0, r = argumentos.length; ++ e < r;) t [argumentos [e]] = w (t); retorno t.of = function (e, r) {função return (i) {try {var u = i.sourceEvent = ao.event; i.target = n, ao.event = i, t [i.type] .apply (e, r)} finalmente {ao.event = u}}}, t} função E (n) {return ko (n, Co), n} função A (n) {retorno "function" == typeof n? n: function () {return Não (n, this)}} função C (n) {retorno "function" == typeof n? n: function () {return Eo (n, isto)}} função z (n, t) {função e () {isto.removeAttribute (n)} função r () {this.removeAttributeNS (n.space, n.local)} função i () {this.setAttribute (n, t)} função u () {this.setAttributeNS (n.space, n.local, t)} função o () {var e = t.apply (isto, argumentos); null == e? this.removeAttribute (n): this.setAttribute (n, e)} função a () { var e = t.apply (isto, argumentos); null == e. this.removeAttributeNS (n.space, n.local): this.setAttributeNS (n.space, n.local, e)} return n = ao. ns.qualify (n), null == t? n.local? r: e: "função" == tipo de t? n.local? a: o: n.local? u: i} função L (n) { return n.trim (). substituir (/ \ s + / g, "")} função q (n) {retornar novo RegExp ("(?: ^ | \\ s +)" + ao.requote (n) + "( ?: \\ s + | $) "," g ")} função T (n) {retorno (n +" "). trim (). divisão (/ ^ | \ s + /)} função R (n, t) { função e () {para (var e = -1; ++ e <i;) n [e] (isto, t)} função r () {para (var e = -1, r = t.apply (isto , argumentos); ++ e <i;) n [e] (isto,r)} n = T (n) .map (D); var i = n.length; retorno "function" == typeof t? r: e} funç˜ao D (n) {var t = q (n); function (e, r) {if (i = e.classList) retorna r? i.add (n): i.remove (n); var i = e.getAttribute ("classe") || ""; r? (t.lastIndex = 0, t.test (i) || e.setAttribute ("classe", L (i + "" + n))): e.setAttribute ("classe", L (i.replace (t, "")))}} function P (n, t, e) {função r () {this.style.removeProperty (n)} função i () {this.style.setProperty (n, t, e)} função u () {var r = t.apply (isto, argumentos); null == r? this.style.removeProperty (n): this.style.setProperty (n, r, e)} retornar null == t? r : "function" == typeof t? u: i} função U (n, t) {função e () {delete this [n]} função r () {this [n] = t} função i () {var e = t.apply (this, arguments); null == e? delete this [n]: este [n] = e} retorna null == t? e: "função" == typeof t? i:r} função j (n) {função t () {var t = this.ownerDocument, e = this.namespaceURI; return e === zo && t.documentElement.namespaceURI === zo? t.createElement (n): t. createElementNS (e, n)} function e () {retornar this.ownerDocument.createElementNS (n.space, n.local)} retornar "function" == typeof n? n: (n = ao.ns.qualify (n) ) .local? e: t} função F () {var n = this.parentNode; n && n.removeChild (this)} função H (n) {retorno {__ data __: n}} função O (n) {função de retorno () {return Ao (this, n)}} função I (n) {return argumentos.length || (n = e), função (t, e) {retorno t && e? n (t .__ dados __, e .__ data__):! t-! e}} função Y (n, t) {para (var e = 0, r = n.length; r> e; e ++) para (var i, u = n [e], o = 0, a = u.length; a> o; o ++) (i = u [o]) && t (i, o, e); retorno n} função Z (n) {retorno ko (n, qo), n} função V ( n) {var t, e; função de retorno (r, i, u) {var, a = n [u] .atualização, l = a.length; para (u! = e && (e = u, t = 0 ), i> = t &&(t = i + 1);! (o = a [t]) && ++ t <l;); retorno o}} função X (n, t, e) {função r () {var t = this [ o &; (this.removeEventListener (n, t, t. $), delete esta função [o])} i () {var i = l (t, co (argumentos)); r.call (isto), this.addEventListener (n, este [o] = i, i. $ = e), i ._ = t} função u () {var t, e = novo RegExp ("^ __ on ([^.] +)" + ao.requote (n) + "$"); para (var r neste) if (t = r.match (e)) {var i = this [r]; this.removeEventListener (t [1], i , i. $), delete this [r]}} var o = "__ on" + n, a = n.indexOf ("."), l = $; a> 0 && (n = n.slice (0, a c) (); c = e (n = c, l = B), a? t? i: r: t? b: u} função $ (n, t) {função de retorno () e) {var r = ao.event; ao.event = e, t [0] = isto .__ data __; tente {n.apply (isto, t)} finalmente {ao.event = r}}} função B (n , t) {var e = $ (n, t); função de retorno (n) {var t = this, r = n.relatedTarget; r && (r === t || 8 & r.compareDocumentPosition (t)) || e .call (t,n)}} função W (e) {var r = ". dragsuppress -" + ++ Faça, i = "clique" + r, u = ao.select (t (e)). on ("touchmove" + r , S) .on ("dragstart" + r, S) .on ("selectstart" + r, S); if (null == Ro && (Ro = "onselectstart" em e?! 1: x (e.style, "userSelect")), Ro) {var o = n (e) .style, a = o [Ro]; o [Ro] = "nenhum"} função de retorno (n) {if (u.on (r, null ), Ro && (o [Ro] = a), n) {var t = função () {u.on (i, nulo)}; u.on (i, função () {S (), t ()} ,! 0), setTimeout (t, 0)}}} função J (n, e) {e.changedTouches && (e = e.changedTouches [0]); var r = n.ownerSVGElement || n; if (r. createSVGPoint) {var i = r.createSVGPoint (); if (0> Po) {var u = t (n); if (u.scrollX || u.scrollY) {r = ao.select ("corpo"). append ("svg"). style ({position: "absoluto", top: 0, left: 0, margin: 0, padding: 0, limite: "nenhum"}, "importante"); var o = r [0 ] [0]getScreenCTM (); Po =! (de || oe), r.remove ()}} return Po? (ix = e.pageX, iy = e.pageY) :( ix = e.clientX, iy = e.clientY ), i = i.matrixTransform (n.getScreenCTM (). inverse ()), [ix, iy]} var a = n.getBoundingClientRect (); retorno [e.clientX-a.left-n.clientLeft, e. clientY-a.top-n.clientTop]} função G () {return ao.event.changedTouches [0] .identifier} função K (n) {retorno n> 0? 1: 0> n? -1: 0} função Q (n, t, e) {retorno (t [0] -n [0]) * (e [1] -n [1]) - (t [1] -n [1]) * (e [ 0] -n [0])} funç˜ao nn (n) {return n> 1? 0: -1> n Fo: Math.acos (n)} funç˜ao tn (n) {return n> 1? Io: - 1> n? -Io: Math.asin (n)} função en (n) {return (n = Math.exp (n)) - 1 / n) / 2} função rn (n) {return ((n = Math.exp (n)) + 1 / n) / 2} função un (n) {função return ((n = Math.exp (2 * n)) - 1) / (n + 1)} em (n ) {return (n = Math.sin (n / 2)) * n} function an () {} função ln (n, t, e) {retornar esta instância de ln? (this.h = + n, this.s = + t, void (this.l = + e)): argumentos.length <2? N exemplo de ln? New ln (nh, ns, nl): _ n ("" + n, wn, ln): nova função ln (n, t, e)} cn (n, t, e) {função r (n) {retornar n> 360? n- = 360: 0> n && (n + = 360), 60> n? u + (ou) * n / 60: 180> n? o: 240> n? u + (ou) * (240-n) / 60: u} função i (n) {return Math.round (255 * r (n))} var u, o; retorno n = éNaN (n)? 0: (n% = 360 ) <0? N + 360: n, t = ï¿½NaN (t)? 0: 0> t? 0: t> 1? 1: t, e = 0> e? 0: e> 1? 1: e, o = .5> = e? E * (1 + t): e + te * t, u = 2 * e, novo mn (i (n + 120), i (n), i (n-120)}} função fn (n, t, e) {retornar essa instância de fn? (this.h = + n, this.c = + t, void (this.l = + e)): argumentos.length <2? n exemploof fn ? new fn (nh, nc, nl): n exemplo de hn? gn (nl, na, nb): gn ((n = Sn ((n = ao.rgb (n)). r, ng, nb)). l, na, nb): novo fn (n, t, e)} função sn (n, t, e) {retorno éNaN (n) && (n = 0), isNaN (t) && (t = 0), novo hn (e, Math.cos (n * = Yo) * t, Math.sin (n) * t)} função hn (n, t, e) {retornar essa instância de hn? (this.l = + n, this.a = + t, void (isto.b = + e)): argumentos.length <2? n exemplo de hn? nova hn (nl, na, nb): n instância de fn? sn (nh, nc, nl): Sn ((n = mn (n)) .r, ng, nb): nova função hn (n, t, e)} pn (n, t, e) {var r = (n + 16) / 116, i = r + t / 500, u = re / 200; return i = vn (i) * na, r = vn (r) * ta, u = vn (u) * ea, novo mn (yn (3.2404542 * i-1.5371385 * r-.4985314 * u), yn (-. 969266 * i + 1,8760108 * r + .041556 * u), yn (0556434 * i-.2040259 * r + 1,0572252 * u))} função gn (n, t, e) {retorno n> 0? new fn (Math.atan2 (e, t) * Zo, Math.sqrt (t * t + e * e), n): nova função fn (NaN, NaN, n)} vn (n) {return n>. 206893034? N * n * n: (n-4/29) /7.787037} funç˜ao dn (n) {return n> .008856? Math.pow (n, 1/3): 7.787037 * n + 4/29} funç˜ao yn (n) {retornar Math.round (255 * (. 00304> = n? 12.92 * n: 1.055 * Math.pow (n, 1 / 2.4) -. 055))} função mn (n, t, e) {return this instanceof mn? (this.r = ~~ n, this.g = ~~ t, void (this.b = ~~ e)): argumentos.length <2? n exemplo de mn? new mn (nr, ng, nb): _ n ("" + n, mn, cn): novo mn (n, t,e)} função Mn (n) {return novo mn (n >> 16, n >> 8 & 255,255 & n)} função xn (n) {retorno Mn (n) + ""} função bn (n) {retorno 16> n "0" + Math.max (0, n) .toString (16): Math.min (255, n) .toString (16)} função _n (n, t, e) {var r, i, u , o = 0, a = 0, l = 0; se (r = / ([az] +) \ ((. *) \) /. exec (n = n.toLowerCase ())) opção (i = r [2] .split (","), r [1]) {caso "hsl": retornar e (parseFloat (i [0]), parseFloat (i [1]) / 100, parseFloat (i [2]) / 100); caso "rgb": retorno t (Nn (i [0]), Nn (i [1]), Nn (i [2])}} return (u = ua.get (n))? (ur, ug, ub) :( null == n || "#"! == n.charAt (0) || isNaN (u = parseInt (n.slice (1), 16)) || (4 = == n.length? (o = (3840 & u) >> 4, o = o >> 4 | o, a = 240 & u, a = a >> 4 | a, l = 15 & u, l = l << 4 | l ): 7 === n.length && (o = (16711680 & u) >> 16, a = (65280 & u) >> 8, l = 255 & u)), t (o, a, l))} função wn (n, t , e) {var r, i, u = Math.min (n / = 255, t / = 255,e / = 255), o = Math.max (n, t, e), a = ou, l = (o + u) / 2; retorno a? (i = .5> l? a / (o + u ): a / (2-ou), r = n = = o (te) / a + (e> t? 6: 0): t = = o? (en) / a + 2: (nt) / a + 4, r * = 60): (r = NaN, i = l> 0 && 1> l? 0: r), novo ln (r, i, l)} função Sn (n, t, e) {n = kn (n), t = kn (t), e = kn (e); var r = dn ((. 4124564 * n + .3575761 * t + .1804375 * e) / na), i = dn ((. 2126729 * n + .7151522 * t + .072175 * e) / ta), u = dn ((. 0193339 * n + .119192 * t + .9503041 * e) / ea); retorno hn (116 * i-16.500 * (ri), 200 * (iu))} função kn (n) {retorno (n / = 255) <=. 04045? n / 12.92: Math.pow ((n + 0,055) /1,055,2,4)} função Nn (n) {var = parseFloat (n); retorno "%" === n.charAt (n.length-1)? Math.round (2.55 * t): t} função En (n) {retorno "function" == typeof n? n: function () {return n}} function Uma (n) {função de retorno (t, e, r) {return 2 === arguments.length && "função" == typeof e && (r = e, e = null) , Cn (t, e, n, r)}} função Cn (n, t, e, r) {função i () {var n, t = l.status; if (!t && Ln (l) || t> = 200 && 300> t || 304 === t) {try {n = e.call (u, l)} captura (r) {retorno void o.error.call (u, r )} o.load.call (u, n)} mais o.error.call (u, l)} var u = {}, o = ao.dispatch ("beforesend", "progress", "load", " erro "), a = {}, l = new XMLHttpRequest, c = nulo; retorna! this.XDomainRequest ||" withCredentials "em l ||! / ^ (http (s)?:)? \ / \ //. teste (n) || (l = novo XDomainRequest), "onload" em l? l.onload = l.onerror = i: l.onreadystatechange = função () {l.readyState> 3 && i ()}, l.onprogress = function (n) {var.t = ao.event; ao.event = n; tente {o.progress.call (u, l)} finalmente {ao.event = t}}, u.header = função (n, t ) {return n = (n + ""). toLowerCase (), arguments.length <2? a [n]: (null == t? deletar a [n]: a [n] = t + "", u)} , u.mimeType = function (n) {return argumentos.length? (t = null == n? null: n + "", u): t}, u.responseType = function (n) {return argumentos.length? (c = n, u): c}, u.response = função (n) {retorno e = n, u}, ["get", "post"]. forEach (função (n) {u [n] = função () {retorno u.send.apply (u, [n] .concat (co (argumentos)))}}), u.send = função (e, r , i) {if (2 === arguments.length && "function" == tipoof r && (i = r, r = nulo), l.open (e, n,! 0), nulo == t || "aceitar "em a || (a.accept = t +", * / * "), l.setRequestHeader) para (var f em a) l.setRequestHeader (f, a [f]); retorno nulo! = t && l.overrideMimeType && l. overrideMimeType (t), nulo! = c && (l.responseType = c), nulo! = i && u.on ("erro", i) .on ("load", função (n) {i (nulo, n)}) , o.beforesend.call (u, l), l.send (nulo == r? nulo: r), u}, u.abort = função () {retorno l.abort (), u}, ao.rebind (u, o, "on"), nulo == r? u: u.get (zn (r))} função zn (n) {retorno 1 === n.length? função (t,e) {n (nulo == tεe: nulo)}: n} função Ln (n) {var t = n.responseType; retorno t && "texto"! == t? n.response: n.responseText} function qn (n, t, e) {var r = argumentos.length; 2> r && (t = 0), 3> r && (e = Date.now ()); var i = e + t, u = {c: n, t: i, n: nulo}; retorno aa? aa.n = u: o = u, aa = u, la || (ca = clearTimeout (ca), la = 1, fa (Tn)), u } função Tn () {var n = Rn (), t = Dn () - n; t> 24? (isFinite (t) && (clearTimeout (ca), ca = setTimeout (Tn, t)), la = 0 ): (la = 1, fa (Tn))} função Rn () {para (var n = Date.now (), t = oa; t;) n> = tt && t.c (nt.t) && (tc = nulo), t = tn; retorno n} função Dn () {para (var n, t = oa, e = 1/0; t;) tc? (tt <e && (e = tt), t = (n = t) .n): t = n? nn = tn: oa = tn; retorno aa = n, e} função Pn (n, t) {retorno t- (n? Math.ceil (Math.log (n) /Math.LN10):1 }}function Un (n, t) {var e = Math.pow (10,3 * xo (8-t)); retorno {escala: t> 8? Função (n) {retorno n / e}: function (n) {retorno n * e}, símbolo:n}} função jn (n) {var = n.decimal, e = n.milhares, r = n.grouping, i = n.currency, u = r && e? function (n, t) {para (var i = n.length, u = [], o = 0, a = r [0], l = 0; i> 0 && a> 0 && (l + a + 1> t && (a = Math.max (1, tl)), u.push (n.substring (i- = a, i + a)),! ((l + = a + 1)> t));) a = r [o = (o + 1)% r.length] return u.reverse (). join (e)}: m; função return (n) {var e = ha.exec (n), r = e [1] || "", o = e [2] | | ">", a = e [3] || "-", l = e [4] || "", c = e [5], f = + e [6], s = e [7], h = e [8], p = e [9], g = 1, v = "", d = "", y =! 1, m =! 0; troca (h && (h = + h.substring (1) )), (c || "0" === r && "=" === o) && (c = r = "0", o = "="), p) {caso "n": s =! 0, p = "g"; quebra; caso "%": g = 100, d = "%", p = "f"; quebra; caso "p": g = 100, d = "%", p = "r"; quebra; caso "b": caso "o ": caso" x ": caso" X ":" # "=== l && (v =" 0 "+ p.toLowerCase ()); caso" c ": m =! 1; caso" d ": y =! 0, h = 0; quebra; caso "s": g = -1, p = "r"} "$" === l && (v = i [0], d = i [1]), " r "! = p || h || (p =" g "), nulo! = h && (" g "== p? h = Math.max (1, Math.min (21, h)):" e "! = p &&" f "! = p || (h = Math.max (0, Math.min (20, h)))), p = pa.get (p) || Fn; var M = c && s; função return (n) {var e = d; if (y & n n 1) return ""; var i = 0> n || 0 === n && 0> 1 / n? (n = -n, "-"): "-" === a? "": a; if (0> g) {var l = ao.formatPrefix (n, h); n = l.scale (n), e = l.symbol + d} mais n * = g; n = p (n, h); var x, b, _ = n.lastIndexOf ("."); if (0> _) {var w = m? n.lastIndexOf ("e") : -1; 0> w? (X = n, b = "") :( x = n.substring (0, w), b = n.substring (w)}} mais x = n.substring (0, _), b = t + n.substring (_ + 1) ;! c && s && (x = u (x, 1/0)); var S = v Comprimento + Comprimento x Comprimento + (M 0: Comprimento i), S = Array novo (S = f-S +1) .Junta (r): "; Retorno M && (x = u (k + x, k.length? fb.length: 1/0)), i + = v, n = x + b, ("<" === o? i + n + k: ">" = == o? k + i + n: "^" === o? k.substring (0, S >> = 1) + i + n +.substring (S): i + (M? n: k + n)) + e}}} function Fn (n) {retornar n + ""} function Hn () {this ._ = new Date (arguments.length> 1? Data.UTC.apply (isto, argumentos): argumentos [ 0])} function On (n, t, e) {função r (t) {var e = n (t), r = u (e, 1); retorno rt> te? E: r} função i (e ) {return t (e = n (novo va (e-1)), 1), e} função u (n, e) {retorno t (n = novo va (+ n), e), n} função o (n, r, u) {var o = i (n), a = []; se (u> 1) para (; r> o;) e (o)% u || a.push (nova data ( + o)), t (o, 1); else para (; r> o;) a.push (nova Data (+ o)), t (o, 1); retorne a} função a (n, t,e) {try {va = Hn; var r = novo Hn; retorno r ._ = n, o (r, t, e)} finalmente {va = Data}} n.floor = n, n.round = r, n.ceil = i, n.offset = u, n.range = o; var l = n.utc = Em (n); retorno l.floor = l, l.round = Em (r), l.ceil = Em (i), l.offset = Em (u), l.range = a, n} função Em (n) {função de retorno (t, e) {tente {va = Hn; var r = novo Hn; retorno r ._ = t, n (r, e) ._} finalmente {va = Date}}} função Yn (n) {função t (n) {função t (t) {para (var e, i, u, o = [], a = -1, l = 0; ++ a <r;) 37 === n.charCodeAt (a) && (o.push (n.slice (l, a)), null! = ( i = ya [e = n.charAt (++ a)]) && (e = n.charAt (++ a)), (u = A [e]) && (e = u (t, nulo = i) "e" === e? "": "0": i)), o.push (e), l = a + 1); retorno o.push (n.slice (l, a)), o .join ("")} var r = n.length; retorno t.parse = função (t) {var r = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: nulo}, i = e (r, n, t, 0); se (i! = T.length) retorna nulo; "p" em r && (rH = rH% 12 + 12 * rp); var u = nulo! = rZ && va! == Hn,o = new (u? Hn: va); return "j" em r? o.setFullYear (ry, 0, rj): "W" em r || "U" em r? ("w" em r || (rw = "W" em r 1: 0), o.setFullYear (ry, 0,1), o.setFullYear (ry, 0, "W" em r? (r.w + 6)% 7 + 7 * rW- (o.getDay () + 5)% 7: r.w + 7 * rU- (o.getDay () + 6)% 7)): o.setFullYear (ry, rm, rd), o. setHours (r.H + (rZ / 100 | 0), r.M + rZ% 100, rS, rL), u? o ._: o}, t.toString = função () {retorno n}, t} função e (n, t, e, r) {para (var i, u, o, a = 0, l = t.length, c = e.length; l> a;) {if (r> = c) retorno -1; if (i = t.charCodeAt (a ++), 37 === i) {se (o = t.charAt (a ++), u = C [o em ya? T.charAt (a ++): o], ! u || (r = u (n, e, r)) <0) return-1} mais if (i! = e.charCodeAt (r ++)) return-1} retorno r} função r (n, t, e) {_. lastIndex = 0; var r = _. exec (t.slice (e)); retorno r? (nw = w.get (r [0]. para menorCaso ()), e + r [0] .length): - 1} função i (n, t, e) {x.lastIndex = 0; var r = x.exec (t.slice (e)); retorno r? (nw = b.get (r [) 0] .toLowerCase ()), e + r [0].length): - 1} function u (n, t, e) {N.lastIndex = 0; var r = N.exec (t.slice (e)); retorno r? (nm = E.get (r [0 ] .toLowerCase ()), e + r [0] .length): - 1} funão o (n, t, e) {S.lastIndex = 0; var r = S.exec (t.slice (e)) ; return r (nm = k.get (r [0]. toLowerCase ()), e + r [0] .comprimento): - 1} funcao a (n, t, r) {retorno e (n, ActoString (), t, r)} função l (n, t, r) {return e (n, AxtoString (), t, r)} função c (n, t, r) {retorno e (n, AXtoString () , t, r)} função f (n, t, e) {var r = M.get (t.slice (e, e + = 2) .toLowerCase ()); retorno null == r? -1: (np = r, e)} var = n.dateTime, h = n.date, p = n.time, g = n.periodos, v = n.days, d = n.shortDays, y = n.mês, m = n.shortMonths; t.utc = função (n) {função e (n) {try {va = Hn; var t = new va; retorno t ._ = n, r (t)} finalmente {va = Date} } var r = t (n); return e.parse = função (n) {try {va = Hn; var t = r.parse (n); retorno t && t ._} finalmente {va = Date}}, e. toString = r.toString, e}, t.multi = t.utc.multi = ct; var M = ao.map (), x = Vn (v), b = Xn (v), _ = Vn (d) ,w = Xn (d), S = Vn (y), k = Xn (y), N = Vn (m), E = Xn (m); g.forCada (funo (n, t) {M.set ( n.toLowerCase (), t)}); var A = {a: function (n) {retorno d [n.getDay ()]}, A: function (n) {retorno v [n.getDay ()]} b: function (n) {retorno m [n.getMonth ()]}, B: função (n) {retorno y [n.getMonth ()]}, c: t (s), d: função (n, t) {retorno Zn (n.getDate (), t, 2)}, e: função (n, t) {retorno Zn (n.getDate (), t, 2)}, H: função (n, t) {return Zn (n.getHours (), t, 2)}, I: função (n, t) {retorno Zn (n.getHours ()% 12 || 12, t, 2)}, j: function (n , t) {retorno Zn (1 + ga.dayOfYear (n), t, 3)}, L: função (n, t) {retorno Zn (n.getMilliseconds (), t, 3)}, m: função ( n, t) {retorno Zn (n.getMonth () + 1, t, 2)}, M: função (n, t) {retorno Zn (n.getMinutes (), t, 2)}, p: function ( n) {return g [+ (n.getHours ()> = 12)]}, S: função (n, t) {retorno Zn (n.getSeconds (), t, 2)}, U: função (n, t) {retorno Zn (ga.sundayOfYear (n), t, 2)}, w: função (n) {retorno n.getDay ()}, W: função (n, t) {retorno Zn (ga.mondayOfYear ( n), t,2)}, x: t (h), X: t (p), y: função (n, t) {retorno Zn (n.getFullYear ()% 100, t, 2)}, Y: função (n, t) {return Zn (n.getFullYear ()% 1e4, t, 4)}, Z: at, "%": function () {retorno "%"}}, C = {a: r, A: i, b:, o o o o o o o o o,,,,,,,,,,,,,,,,,,,,,,,,,,,,, it it it ut, U: Bn, w: $ n, W: Wn, x: l, X: c, y: Gn, Y: Jn, Z: Kn, "%": lt}; retorno t} função Zn (n, t, e) {var r = 0> n? "-": "", i = (r? -n: n) + "", u = i.length; retorno r + (e> u? novo Matriz (e -u + 1) .join (t) + i: i)} função Vn (n) {retornar novo RegExp ("^ (?:" + n.map (ao.requote) .join ("|") + " ) "," i ")} função Xn (n) {para (var t = novo c, e = -1, r = n.length; ++ e <r;) t.set (n [e] .toLowerCase (), e); return t} função $ n (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 1)); retorno r? (nw = + r [0], e + r [0] .comprimento): - 1} função Bn (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e)) Retornar r (nU = + r [0], e + r [0]. comprimento):-1} função Wn (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e)); retorno r? (NW = + r [0], e + r [ 0] .length): - 1} funç˜ao Jn (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 4)); retorno r? (Ny = + r [0], e + r [0] .comprimento): - 1} funç˜ao Gn (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e +) 2)); return r? (Ny = Qn (+ r [0]), e + r [0] .comprimento): - 1} função Kn (n, t, e) {retorno / ^ [+ -] \ d {4} $ / teste (t = t.slice (e, e + 5))? (nZ = -t, e + 5): - 1} função Qn (n) {retorno n + (n> 68? 1900: 2e3)} função nt (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 2)); retorno r? (Nm = r [0] -1, e + r [0] .comprimento): - 1} função tt (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 2)) ; return r? (nd = + r [0], e + r [0] .comprimento): - 1} funç˜ao et (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t .slice (e, e + 3)); retorno r? (nj = + r [0], e + r [0] .comprimento): - 1} funç˜ao rt (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 2)); retorno r? (NH = + r [0], e + r [0] .comprimento): - 1} funcao it (n te) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 2)); retorno r? (nM = + r [0], e + r [0] .comprimento): -1} funç˜ao ut (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 2)); retorno r? (NS = + r [0], e + r [0] .comprimento): - 1} function ot (n, t, e) {ma.lastIndex = 0; var r = ma.exec (t.slice (e, e + 3)); (nL = + r [0], e + r [0] .comprimento): - 1} function at (n) {var = n.getTimezoneOffset (), e = t> 0? "-": "+ ", r = xo (t) / 60 | 0, i = xo (t)% 60; retorno e + Zn (r," 0 ", 2) + Zn (i," 0 ", 2)} função lt ( n, t, e) {Ma.lastIndex = 0; var r = Ma.exec (t.slice (e, e + 1)); retorno r e e + r [0] .comprimento: -1} funç ão ct ( n) {para (var t = n.length, e = -1; ++ e <t;) n [e] [0] = isto (n [e] [0]); função de retorno (t) {para (var e = 0, r = n [e]; r [1] (t);) r = n [++ e]; retorno r [0] (t)}} função ft () {} função st (n, t, e) {var r = es = n + t, i = rn, u = ri; et = n -u + (ti)} função ht (n, t) {n && wa.hasOwnProperty (n.type) && wa [n.type] (n, t)} função pt (n, t, e) {var r,i = -1, u = n.length-e, para (t.lineStart (); ++ i <u;) r = n [i], t.point (r [0], r [1], r [2]); t.lineEnd ()} function gt (n, t) {var e = -1, r = n.length; para (t.polygonStart (); ++ e <r;) pt (n [n e], t, 1); t.polygonEnd ()} função vt () {função n (n, t) {n * = Yo, t = t * Yo / 2 + Fo / 4; var e = nr, o = e> = 0? 1: -1, a = o * e, l = Math.cos (t), c = Math.sin (t), f = u * c, s = i * l + f * Math .cos (a), h = f * o * Math.sin (a); ka.add (Math.atan2 (h, s)), r = n, i = l, u = c} var t, e, r, i, u; Na.ponto = função (o, a) {Na.point = n, r = (t = o) * Yo, i = Math.cos (a = (e = a) * Yo / 2 + Fo / 4), u = Math.sin (a)}, Na.lineEnd = função () {n (t, e)}} função dt (n) {var = n [0], e = n [ 1], r = Math.cos (e); retorno [r * Math.cos (t), r * Math.sin (t), Math.sin (e)]} funç˜ao yt (n, t) {return n [0] * t [0] + n [1] * t [1] + n [2] * t [2]} funo mt (n, t) {retorno [n [1] * t [2] -n [2] * t [1], n [2] * t [0] -n [0] * t [2], n [0] * t [1] -n [1] * t [0]]} função Mt (n, t) {n [0] + = t [0], n [1] + = t [1], n [2] + = t [2]} função xt (n, t) {retorno [n [0] * t, n [1] * t,n [2] * t]} function bt (n) {var = Math.sqrt (n [0] * n [0] + n [1] * n [1] + n [2] * n [2] ); n [0] / = t, n [1] / = t, n [2] / = t} função _t (n) {retorno [Math.atan2 (n [1], n [0]), tn (n [2])]} função wt (n, t) {retorno xo (n [0] -t [0]) <Uo && xo (n [1] -t [1]) <Uo} função St (n, t) {n * = Yo; var e = Math.cos (t * = Yo); kt (e * Math.cos (n), e * Math.sin (n), Math.sin (t))} kt (n, t, e) {++ Ea, Ca + = (n-Ca) / Ea, za + = (t-za) / Ea, La + = (e-La) / Ea} função Nt () {função n (n, i) {n * = Yo; var u = Math.cos (i * = Yo), o = u * Math.cos (n), a = u * Math.sin (n), l = Math. sin (i), c = Math.atan2 (Math.sqrt ((c = e * lr * a) * c + (c = r * ot * l) * c + (c = t * ae * o) * c), t * o + e * a + r * l); Aa + = c, qa + = c * (t + (t = o)), Ta + = c * (e + (e = a)), Ra + = c * (r + ( r = l)), kt (t, e, r)} var t, e, r; ja.point = função (i, u) {i * = Yo; var o = Math.cos (u * = Yo) ; t = o * Math.cos (i), e = o * Math.sin (i), r = Math.sin (u), ja.point = n, kt (t, e, r)}} fun () {ja.point = St} function At () {função n (n, t) {n * = Yo; var e = Math.cos (t * = Yo), o = e * Math.cos (n) ,a = e * Math.sin (n), l = Math.sin (t), c = i * lu * a, f = u * ou * l, s = r * ai * o, h = Math.sqrt ( c * c + f * f + s * s), p = r * o + i * a + u * l, g = h && - nn (p) /h, v = Mat.atan2 (h, p); Da + = g * c, Pa + = g * f, Ua + = g * s, A + = v, qa + = v * (r + (r = o)), Ta + = v * (i + (i = a)), Ra + = v * (u + (u = l)), kt (r, i, u)} var t, e, r, i, u; ja.point = função (o, a) {t = o, e = a, ja ponto = n, o * = Yo; var l = Math.cos (a * = Yo); r = l * Math.cos (o), i = l * Math.sin (o), u = Math.sin (a), kt (r, i, u)}, ja.lineEnd = função () {n (t, e), ja.lineEnd = Et, ja.point = St}} função Ct (n, t) { função e (e, r) {return e = n (e, r), t (e [0], e [1])} return n.invert && t.invert && (e.invert = função (e, r) {retorno e = t.invert (e, r), e && n.invert (e [0], e [1])}), e} função zt () {return! 0} função Lt (n, t, e, r, i) {var u = [], o = []; se (n.forEach (function (n) {if (! ((t = n.length-1) <= 0)) {var t, e = n [0], r = n [t]; se (wt (e, r)) {i.lineStart (); para (var a = 0; t> a; ++ a) i.point ((e = n [a]) [0], e [1]); return void i.lineEnd ()} var l = novo Tt (e, n,null,! 0), c = novo Tt (e, nulo, l,! 1); lo = c, u.push (l), o.push (c), l = novo Tt (r, n, nulo, ! 1), c = novo Tt (r, nulo, l,! 0), lo = c, u.push (l), o.push (c)}}), o.sort (t), qt (u ), qt (o), u.length) {para (var a = 0, l = e, c = o.length; c> a; ++ a) o [a] .e = l =! l; (var f, s, h = u [0] ;;) {para (var p = h, g =! 0; pv;) se ((p = pn) === h) retorno; f = pz, i .lineStart (); faz {if (pv = pov =! 0, pe) {if (g) para (var a = 0, c = f.length; c> a; ++ a) i.point ((s = f [a]) [0], s [1]), senão r (px, pnx, 1, i); p = pn} mais {if (g) {f = ppz; para (var a = f. length-1; a> = 0; - a) i.ponto ((s = f [a]) [0], s [1])} mais r (px, ppx, -1, i); p = pp} p = po, f = pz, g =! g} while (! pv); i.lineEnd ()}}} função qt (n) {if (t = n.length) {para (var t, e , r = 0, i = n [0]; ++ r <t;) in = e = n [r], ep = i, i = e; in = e = n [0], ep = i}} função Tt (n, t, e, r) {this.x = n, this.z = t, this.o = e, this.e = r, this.v =! 1, this.n = this.p = null função Rt (n, t, e, r) {função de retorno (i, u) {função o (t, e) {var r = i (t, e); n (t = r [0], e = r [1]) && u.point (t,e)} função a (n, t) {var e = i (n, t); d.ponto (e [0], e [1])} função l () {m.point = a, d.lineStart ()} função c () {m.point = o, d.lineEnd ()} função f (n, t) {v.push ([n, t]); var e = i (n, t); (e [0], e [1])} função s () {x.lineStart (), v = []} função h () {f (v [0] [0], v [0] [ 1]), x.lineEnd (); var n, t = x.clean (), e = M.buffer (), r = e.length; if (v.pop (), g.push (v), v = null, r) if (1 & t) {n = e [0]; var i, r = n.length-1, o = -1; if (r> 0) {para (b || (u.polygonStart) (), b =! 0), u.lineStart (); ++ o <r;) u.point ((i = n [o]) [0], i [1]); u.lineEnd ()} } else r> 1 && 2 & t && e.push (e.pop (). concat (e.shift ())), p.push (e.filter (Dt))} var p, g, v, d = t (u), y = i.invert (r [0], r [1]), m = {ponto: o, lineStart: l, linhaEnd: c, polygonStart: function () {m.point = f, m.lineStart = s, m.lineEnd = h, p = [], g = []}, polígonEnd: function () {m.point = o, m.lineStart = l, m.lineEnd = c, p = ao.merge (p); var n = Ot (y, g); p.length? (b || (u.polygonStart (), b =! 0), Lt (p, Ut, n, e, u)):n && (b || (u.polygonStart (), b =! 0), u.lineStart (), e (nulo, nulo, 1, u), u.lineEnd ()), b && (u.polygonEnd (), b =! 1), p = g = null}, esfera: function () {u.polygonStart (), u.lineStart (), e (nula, nula, 1, u), u.lineEnd (), u. polygonEnd ()}}, M = Pt (), x = t (M), b =! 1; retorno m}} função Dt (n) {retorno n.length> 1} função Pt () {var n, t = []; return {lineStart: função () {t.push (n = [])}, ponto: função (t, e) {n.push ([t, e])}, lineEnd: b, buffer: function () {var e = t; retorno t = [], n = nulo, e}, reingressar: function () {t.length> 1 && t.push (t.pop (). concat (t.shift ()) )}}} função Ut (n, t) {retorno ((n = nx) [0] <0? n [1] -Io-Uo: Io-n [1]) - ((t = tx) [0 ] <0? T [1] -Io-Uo: Io-t [1])} funcao jt (n) {var t, e = NaN, r = NaN, i = NaN; retorno {lineStart: funcao () { n.lineStart (), t = 1}, ponto: função (u, o) {var a = u> 0 Fo: -Fo, l = xo (ue); xo (l-Fo) <Uo? ponto (e, r = (r + o) / 2> 0? Io: -Io), n.point (i, r), n.lineEnd (), n.lineStart (), n.point (a, r), n.ponto (u, r), t = 0): i! == a && l> = Fo && (xo (ei) <Uo && (e- = i * Uo), xo (ua) <Uo && (u- = a * Uo) , r = Ft (e, r, u, o), n.point (i, r), n.lineEnd (), n.lineStart (), n.point (a, r), t = 0), n Função .point (e = u, r = o), i = a}, lineEnd: function () {n.lineEnd (), e = r = NaN}, clean: function () {retorno 2-t}}} Ft (n, t, e, r) {var i, u, o = Math.sin (ne); retorno xo (o)> Uo? Math.atan ((Math.sin (t) * (u = Math). cos (r)) * Math.sin (e) -Math.sin (r) * (i = Math.cos (t)) * Math.sin (n)) / (i * u * o)): (t + r) / 2} function Ht (n, t, e, r) {var i; if (null == n) i = e * Io, r.point (-Fo, i), r.ponto (0, i), r.ponto (Fo, i), r.ponto (Fo, 0), r.ponto (Fo, -i), r.ponto (0, -i), r.ponto (-Fo, -i ), r.point (-Fo, 0), r.point (-Fo, i), senão se (xo (n [0] -t [0])> Uo) {var u = n [0] <t [0]: Fo: -Fo; i = e * u / 2, r.ponto (-u, i), r.ponto (0, i), r.ponto (u, i)} mais r.ponto ( t [0], t [1])} função Ot (n, t) {var e = n [0], r = n [1], i = [Math.sin (e), - Math.cos (e ), 0], u = 0, o = 0; ka.reset (); para (var a = 0, l = t.comprimento; l> a; ++ a) {var = v [a], f = c.length; se (f) para (var s = c [0], h = s [0], p = s [ 1] /2+Fo/4,g=Math.sin (p), v = Math.cos (p), d = 1 ;;) {d === f && (d = 0), n = c [d ]; var y = n [0], m = n [1] / 2+Fo/4, M = Matr.sin (m), x = Math.cos (m), b = yh, _ = b> = 0? 1: -1, w = _ * b, S = w> Fo, k = g * M; se (ka.add (Math.atan2 (k * _ * Math.sin (w), v * x + k * Math.cos (w))), u + = S? b + _ * Ho: b, S ^ h> = e ^ y> = e) {var N = mt (dt (s), dt (n) bt (N); var E = mt (i, N); bt (E); var A = (S ^ b> = 0? -1: 1) * tn (E [2]); (r> A || r === A && (N [0] || N [1])) && (o + = S ^ b> = 0? 1: -1)} se (! D ++) quebra; h = y, g = M, v = x, s = n}} return (-Uo> u || Uo> u && - Uo> ka) ^ 1 & o} function É (n) {função t (n, t) {retorna Math.cos ( n) * Math.cos (t)> u} função e (n) {var e, u, l, c, f; retorno {lineStart: function () {c = l =! 1, f = 1}, ponto : função (s, h) {var p, g = [s, h], v = t (s, h), d = o? v? 0: i (s, h): v? i (s + (0 > s Fo: -Fo), h): 0; se (! e && (c = l = v) && n.lineStart (), v! == l && (p = r (e, g), (wt (e ,p) || wt (g, p)) && (g [0] + = Uo, g [1] + = Uo, v = t (g [0], g [1]))), v! == l) f = 0, v? (n.lineStart (), p = r (g, e), n.ponto (p [0], p [1])): (p = r (e, g), n.point (p [0], p [1]), n.lineEnd ()), e = p; else if (a && e && o ^ v) {var y; d & u ||! (y = r (g, e, ! 0)) || (f = 0, o? (N.LinhaStart (), n.Ponto (y [0] [0], y [0] [1]), n.Ponto (y [1] [ 0], y [1] [1]), n.lineEnd ()): (n.ponto (y [1] [0], y [1] [1]), n.lineEnd (), n.lineStart (), n.ponto (y [0] [0], y [0] [1])))}! v || e && wt (e, g) || n.ponto (g [0], g [1 ]), e = g, l = v, u = d}, lineEnd: function () {l && n.lineEnd (), e = null}, clean: function () {retorno f | (c && l) << 1}} } função r (n, t, e) {var r = dt (n), i = dt (t), o = [1,0,0], a = mt (r, i), l = yt (a , a), c = a [0], f = lc * c; if (! f) return! e && n; var = u * l / f, h = -u * c / f, p = mt (o, a), g = xt (o, s), v = xt (a, h); Mt (g, v); var d = p, y = yt (g, d), m = yt (d, d) , M = y * ym * (yt (g, g) -1); se (! (0> M)) {var x = Math.sqrt (M), b = xt (d, (- yx) / m ); se (Mt (b, g), b = _t (b),! e) retornar b; var _, w = n [0],S = t [0], k = n [1], N = t [1]; w> S && (_ = w, w = S, S = _); var E = Sw, A = xo (E-Fo ) <Uo, C = A || Uo> E; se (! A && k> N && (_ = k, k = N, N = _), C? A? K + N> 0 ^ b [1] <(xo (b [0] -w) <Uo? k: N): k <= b [1] && b [1] <= N: E> Fo ^ (w <= b [0] && b [0] <= S )) {var z = xt (d, (- y + x) / m); retorno mt (z, g), [b, _t (z)]}}} função i (t, e) {var r = o? n: Fo-n, i = 0; return-r> t? i | = 1: t> r && (i | = 2), - r> e? i | = 4: e> r && (i | = 8), i} var = Math.cos (n), o = u> 0, a = xo (u)> Uo, l = ve (n, 6 * Yo); retorno Rt (t, e, l, o? [0, -n]: [- Fo, n-Fo])} função Yt (n, t, e, r) {função de retorno (i) {var u, o = ia, a = ib, l = ox, c = oy, f = ax, s = ay, h = 0, p = 1, g = fl, v = sc; se (u = nl, g ||! (u> 0)) {se (u / = g, 0> g) {se (h> u) retornar; p> u && (p = u)} mais se (g> 0) {se (u> p) retornar; u> h && (h = u) } if (u = el, g ||! (0> u)) {se (u / = g, 0> g) {se (u> p) retornar; u> h && (h = u)} mais se ( g> 0) {se (h> u) retornar; p>u && (p = u)} se (u = tc, v ||! (u> 0)) {se (u / = v, 0> v) {se (h> u) retornar; p> u && (p = u)} else if (v> 0) {se (u> p) retornar; u> h && (h = u)} se (u = rc, v ||! (0> u)) {se (u / = v, 0> v) {se (u> p) retornar; u> h && (h = u)} mais se (v> 0) {se (h> u) retornar; p> u && (p = u)} retornar h> 0 && (ia = {x: l + h * g, y: c + h * v}), 1> p && (ib = {x: l + p * g, y: c + p * v}), i}}}}}} função Zt (n, t, e, r) {função i (r, i) {retorno xo (r [0] -n) <Uo? i> 0? 0: 3: xo ( r [0] -e) <Uo? i> 0? 2: 1: xo (r [1] -t) <Uo? i> 0? 1: 0: i> 0? 3: 2} funo u (n , t) {retorno o (nx, tx)} função o (n, t) {var e = i (n, 1), r = i (t, 1); retorno e! == r? er: 0 = == e? t [1] -n [1]: 1 === e? n [0] -t [0]: 2 === e? n [1] -t [1]: t [0] -n [0]} função de retorno (a) {função l (n) {para (var t = 0, e = comprimento_ d, r = n [1], i = 0; e> i; ++ i) para (var u, o = 1, a = d [i], l = comprimento, c = a [0]; l> o; ++ o) u = a [o], c [1] <= r? u [1]> r && Q (c, u, n)> 0 && ++ t:u [1] <= r && Q (c, u, n) <0 && - t, c = u; retorno 0! == t} função c (u, a, l, c) {var f = 0, s = 0; if (null == u || (f = i (u, l))! == (s = i (a, l)) || o (u, a) <0 ^ l> 0) {fazer c.point (0 === f || 3 === f? n: e, f> 1? r: t), enquanto ((f = (f + l + 4)% 4)! == s) } mais c.point (a [0], a [1])} função f (i, u) {retorno i> = n && e> = i && u> = t && r> = u} função s (n, t) {f ( n, t) && a.ponto (n, t)} função h () {ponto C. = g, d && d.push (y = []), S =! 0, w =! 1, b = _ = NaN} função p () {v && (g (m, M), x && w && E.rejoin (), v.push (E. buffer ())), C. ponto = s, w && a.lineEnd ()} função g (n, t ) {n = Math.max (-Ha, Math.min (Ha, n)), t = Math.max (-Ha, Math.min (Ha, t)); var e = f (n, t); if (d && y.push ([n, t]), S) m = n, M = t, x = e, S =! 1, e && (a.lineStart (), a.ponto (n, t)); else if (e & w) a.ponto (n, t); senão {var r = {a: {x: b, y: _}, b: {x: n, y: t}}; A (r)? (w || (a.lineStart (), a.point (rax, ray)), a.ponto (rbx, rby), e || a.lineEnd (), k =! 1): e && (a.lineStart (), a.ponto (n, t), k =! 1)} b = n, _ = t , w = e} var v, d, y, m, M, x, b, _, w, S, k, N = a, E = Pt (), A = Yt (n, t, e, r) , C = {ponto: s, lineStart: h, linhaEnd: p, polygonStart: function () {a = E, v = [], d = [], k =! 0}, polygonEnd: function () {a = N, v = ao.merge (v); var t = l ([n, r]), e = k && t, i = v.length; (e || i) && (a.polygonStart (), e && (a .lineStart (), c (nulo, nulo, 1, a), a.lineEnd ()), i && Lt (v, u, t, c, a), a.polygonEnd ()), v = d = y = nulo }}; return C}} função Vt (n) {var t = 0, e = Fo / 3, r = ae (n), i = r (t, e); retorno i.parallels = função (n) { return arguments.length? r (t = n [0] * Fo / 180, e = n [1] * Fo / 180): [t / Fo * 180, e / Fo * 180]}, i} funo Xt ( n, t) {função e (n, t) {var e = Math.sqrt (u-2 * i * Math.sin (t)) / i; return [e * Math.sin (n * = i), oe * Matemática.cos (n)]} var r = Matemática.sin (n), i = (r + Matemática.sin (t)) / 2, u = 1 + r * (2 * ir), o = Matemática .sqrt (u) / i; return e.invert = função (n, t) {var e = ot; return [Math.atan2 (n, e) / i,tn ((u- (n * n + e * e) * i * i) / (2 * i))]}, e} função $ t () {função n (n, t) {Ia + = i * nr * t, r = n, i = t} var t, e, r, i; $ a.point = função (u, o) {$ a.point = n, t = r = u, e = i = o }, $ a.lineEnd = function () {n (t, e)}} função Bt (n, t) {Ya> n && (Ya = n), n> Va && (Va = n), Za> t && (Za = t), t> Xa && (Xa = t)} função Wt () {função n (n, t) {o.push ("M", n, ",", t, u)} função t (n, t) (o.push) ("M", n, ",", t), a.point = e} function e (n, t) {o.push ("L", n, ",", t) } função r () {a.point = n} função i () {o.push ("Z")} var u = Jt (4.5), o = [], a = {ponto: n, linhaStart: função ( ) {a.point = t}, lineEnd: r, polygonStart: function () {a.lineEnd = i}, polygonEnd: function () {a.lineEnd = r, a.point = n}, pointRadius: função (n ) {return u = Jt (n), a}, resultado: function () {if (o.length) {var n = o.join (""); return o = [], n}}}; } função Jt (n) {return "m0"+ n + "a" + n + "," + n + "0 1,1 0," + - 2 * n + "a" + n + "," + n + "0 1,1 0," + 2 * n + "z" } função Gt (n, t) {Ca + = n, za + = t, ++ La} função Kt () {função n (n, r) {var i = nt, u = re, o = Math.sqrt (i * i + u * u); qa + = o * (t + n) / 2, Ta + = o * (e + r) / 2, Ra + = o, Gt (t = n, e = r)} var t, e. Wa.point = função (r, i) {Wa.point = n, Gt (t = r, e = i)}} função Qt () {Wa.point = Gt} função ne () {função n ( n, t) {var e = nr, u = ti, o = Math.sqrt (e * e + u * u); qa + = o * (r + n) / 2, Ta + = o * (i + t) / 2, Ra + = o, o = i * nr * t, Da + = o * (r + n), Pa + = o * (i + t), Ua + = 3 * o, Gt (r = n, i = t )} var t, e, r, i; Wa.point = função (u, o) {Wa.point = n, Gt (t = r = u, e = i = o)}, Wa.lineEnd = função ( ) {n (t, e)}} função te (n) {função t (t, e) {n.moveTo (t + o, e), n.arc (t, e, o, 0, Ho)} função e (t, e) {n.moveTo (t, e), a.point = r} função r (t, e) {n.lineTo (t, e)} função i () {a.point = t } função u () {n.closePath ()} var o = 4.5, a = {ponto: t, linhaStart: function () {a.point = e}, lineEnd: i,polygonStart: function () {a.lineEnd = u}, polygonEnd: function () {a.lineEnd = i, a.point = t}, pointRadius: função (n) {retorno o = n, a}, resultado: b }; return a} função ee (n) {função t (n) {retorno (a? r: e) (n)} função e (t) {retorno ue (t, função (e, r) {e = n (e, r), t.ponto (e [0], e [1])})} função r (t) {função e (e, r) {e = n (e, r), t.ponto ( e [0], e [1])} função r () {M = NaN, S. ponto = u, t.lineStart ()} função u (e, r) {var u = dt ([e, r] ), o = n (e, r); i (M, x, m, b, w, M = o [0], x = o [1], m = e, b = u [0], _ = u [1], w = u [2], a, t), t.ponto (M, x)} função o () {S. ponto = e, t.lineEnd ()} função l () {função lineStart ()} u (e, r) {var u = dt ([e, r]), o = n (e, r); i (M, x, m, b, _, w, M = o [0], x = o [1], m = e, b = u [0], _ = u [1], w = u [2], a, t), t.ponto (M, x)} função o () {S.ponto = e, t.lineEnd ()} função l () {função lineStart ()} u (e, r) {var u = dt ([e, r]), o = n (e, r); i (M, x, m, b, _, w, M = o [0], x = o [1], m = e, b = u [0], _ = u [1], w = u [2], a, t), t.ponto (M, x)} função o () {S.ponto = e, t.lineEnd ()} função l () {
r (), S. ponto = c, S. linhaEnd = f} função c (n, t) {u (s = n, h = t), p = M, g = x, v = b, d = _ , y = w, S. ponto = u} função f () {i (M, x, m, b, _, w, p, g, s, v, d, y, a, t), linha S. = o, o ()} var s, h, p, g, v, d, y, m, M, x, b, _, w, S = {ponto: e, lineStart: r, linhaEnd: o, polygonStart : function () {t.polygonStart (), S.lineStart = l}, polygonEnd: function () {t.polygonEnd (), S.lineStart = r}}; retorno S} função i (t, e, r, a, l, c, f, s, h, p, g, v, d, y) {var m = ft, M = se, x = m * m + M * M; se (x> 4 * u && d- -) {var b = a + p, _ = l + g, w = c + v, S = Math.sqrt (b * b + _ * _ + w * w), k = Math.asin (w / = S), N = xo (xo (w) -1) <Uo || xo (rh) <Uo? (R + h) / 2: Mat.atan2 (_, b), E = n (N, k) , A = E [0], C = E [1], z = At, L = Ce, q = M * zm * L; (q * q / x> u || xo ((m * z + M *) L) /x-.5)> .3 || o> a * p + l * g + c * v) && (i (t, e, r, a, l, c, A, C, N, b /=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v , d) y))}} var u = .5, o = Math.cos (30 * Yo), a = 16; retorno t.precisão = função (n) {return arguments.length? (a = (u = n * n)> 0 && 16, t): Matemática.Função sqrt (u)}, t} re (n) {var t = ee (função (t, e) {retorno n ([t * Zo, e * Zo])}); função de retorno (n) {return le (t (n))}} function ie (n) {this.stream = n} função ue (n, t) {retorno {ponto: t, esfera: função () {n.sfera ()}, função lineStart: () {n.lineStart ()}, lineEnd: function () {n.lineEnd ()}, polygonStart: function () {n.polygonStart ()}, polygonEnd: function () {n.polygonEnd ()}}} function oe (n) {return ae (function () {return n}) ()} função ae (n) {função t (n) {retornar n = a (n [0] * Yo, n [1] * Yo ), [n [0] * h + l, cn [1] * h]} funç˜ao e (n) {return n = a.invert ((n [0] -l) / h, (cn [1]) / h), n && [n [0] * Zo, n [1] * Zo]} função r () {a = Ct (o = se (y, M, x), u); var n = u (v , d) retorno l = pn [0] * h, c = g + n [1] * h, i ()} função i () {retorno f && (f.válido =! 1, f = nulo), t } var u, o, a, l, c, f, s = ee (função (n, t) {retorno n = u (n, t), [n [0] * h + l, cn [1] * h]}), h = 150, p = 480, g = 250, v = 0, d = 0, y = 0, M = 0, x = 0, b = Fa, _ = m, w = null, S = nulo, retorno t.stream = function (n) {retorno f && (f.valid =! 1), f = le (b (o, s (_ (n)))), f.válido =! 0, f}, t.clipAngle = function (n) {return argumentos.length? (b = null == n? (w = n, Fa): É ((w = + n) * Yo), i ()): w}, t.clipExtent = function (n) {return argumentos.length? (S = n, _ = n? Zt (n [0] [0], n [0] [1], n [1] [0], n [1] [ 1]): m, i ()): S}, tscale = function (n) {return argumentos.length? (H = + n, r ()): h}, t.translate = função (n) {return arguments.length? (p = + n [0], g = + n [1], r ()): [p, g]}, t.center = função (n) {return argumentos.length? ( v = n [0]% 360 * Yo, d = n [1]% 360 * Yo, r ()): [v * Zo, d * Zo]}, t.rotate = função (n) {argumentos de retorno. comprimento? (y = n [0]% 360 * Yo, M = n [1]% 360 * Yo, x = n.length> 2? n [2]% 360 * Yo: 0, r ()): [ y * Zo, M * Zo, x * Zo]}, ao.rebind (t, s, "precisão"), function () {return u = n.apply (isto, argumentos), t.invert = u.invert && e , r ()}} função le (n) {retorno ue (n, função (t, e) {n.point (t * Yo, e * Yo)})} função ce (n, t) {retorno [n t]} função fe (n,t) {return [n> Fo? n-Ho: -Fo> n? n + Ho: n, t]} função se (n, t, e) {retorno n? t || e? Ct (pe (n) ), ge (t, e)): pe (n): t || e? ge (t, e): fe} função he (n) {função de retorno (t, e) {retorno t + = n, [t > Fo-t-Ho: -Fo> t? T + Ho: t, e]}} função pe (n) {var t = ele (n); retorno t.invert = ele (-n), t} função ge (n, t) {função e (n, t) {var e = Math.cos (t), a = Math.cos (n) * e, l = Math.sin (n) * e, c = Math .sin (t), f = c * r + a * i; return [Math.atan2 (l * uf * o, a * rc * i), tn (f * u + l * o)]} var r = Math.cos (n), i = Matemática.sin (n), u = Matemática.cos (t), o = Matemática.sin (t); retorno e.invert = função (n, t) {var e = Matemática .cos (t), a = Math.cos (n) * e, l = Math.sin (n) * e, c = Math.sin (t), f = c * ul * o; retorno [Math.atan2 (l * u + c * o, a * r + f * i), tn (f * ra * i)]}, e} função ve (n, t) {var e = Math.cos (n), r = Math.sin (n); função de retorno (i, u, o, a) {var l = o * t; null! = I? (I = de (e, i), u = de (e, u) , (o> 0? u> i: i> u) && (i + = o * Ho)): (i = n + o * Ho, u = n-.5 * l); para (var c, f = Eu; o> 0? f? u:?> f; f- = l) a.point ((c = _t ([e, -r * Math.cos (f), - r * Math.sin (f)])) [0], c [1])}} função de (n, t) {var e = dt (t); e [0] - = n, bt (e); var r = nn (-e [1]); retorno ((- e [2] <0? -r: r) + 2 * Math.PI-Uo)% (2 * Math. PI)} função ye (n, t, e) {var r = ao.range (n, t-Uo, e). Concat (t); função de retorno (n) {retorno r.map (função (t) { return [n, t]})}} função me (n, t, e) {var r = ao.range (n, t-e, e) .concat (t); função de retorno (n) {retorno r. map (função (t) {retorno [t, n]})}} função Me (n) {retorno n.source} função xe (n) {retorno n.target} função be (n, t, e, r) {var i = Math.cos (t), u = Math.sin (t), o = Math.cos (r), a = Math.sin (r), l = i * Math.cos (n), c = i * Math.sin (n), f = o * Math.cos (e), s = o * Math.sin (e), h = 2 * Math.asin (Math.sqrt (em (rt) + i * o * em (en))), p = 1 / Math.sin (h), g = h? função (n) {var t = Math.sin (n * = h) * p, e = Math.sin (hn) * p, r = e * l + t * f, i = e * c + t * s, o = e * u + t * a; retorno [Math.atan2 (i, r) * Zo, Math .atan2 (o, Math.sqrt (r * r + i * i)) * Zo]}: function () {retorno [n * Zo, t * Zo]}; retorno g.distance = h,g} função _e () {função n (n, i) {var u = Math.sin (i * = Yo), o = Math.cos (i), a = xo ((n * = Yo) -t) , l = Math.cos (a); Ja + = Math.atan2 (Math.sqrt ((a = o * Math.sin (a)) * a + (a = r * ue * o * l) * a), e * u + r * o * l), t = n, e = u, r = o} var t, e, r, Ga.point = função (i, u) {t = i * Yo, e = Math. sin (u * = Yo), r = Math.cos (u), Ga.point = n}, Ga.lineEnd = função () {Ga.point = Ga.lineEnd = b}} function we (n, t) {função e (t, e) {var r = Math.cos (t), i = Math.cos (e), u = n (r * i); retorno [u * i * Math.sin (t), u * Math.sin (e)]} return e.invert = função (n, e) {var r = Math.sqrt (n * n + e * e), i = t (r), u = Math.sin (i), o = Math.cos (i); retorno [Math.atan2 (n * u, r * o), Math.asin (r && e * u / r)]}, e} função Se (n, t) {função e (n, t) {o> 0? -Io + Uo> t && (t = -Io + Uo): t> Io-Uo && (t = Io-Uo); var e = o / Math.pow ( i (t), u); return [e * Math.sin (u * n), oe * Math.cos (u * n)]} var r = Math.cos (n), i = função (n) { retornar Math.tan (Fo / 4 + n / 2)}, u = n === t? Math.sin (n): Math.log (r / Math.cos (t)) / Math.log (i (t) / i (n)), o = r * Math.pow (i (n), u) / u; retorno u? (e.invert = função (n, t) {var e = ot , r = K (u) * Math.sqrt (n * n + e * e); retorno [Math.atan2 (n, e) /u.2*Math.atan (Math.pow (o / r, 1 / u)) - Io]}, e): Ne} função ke (n, t) {função e (n, t) {var e = ut; retorno [e * Math.sin (i * n), ue * Math .cos (i * n)]} var r = Math.cos (n), i = n === t? Math.sin (n) :( r-Math.cos (t)) / (tn), u = r / i + n; retorno xo (i) <Uo? ce: (e.invert = função (n, t) {var e = ut; retorno [Math.atan2 (n, e) / i, uK (i ) Math.sqrt (n * n + e * e)]}, e)} função Ne (n, t) {retorno [n, Math.log (Math.tan (Fo / 4 + t / 2)]] } função Ee (n) {var t, e = oe (n), r = e.scale, i = e.translate, u = e.clipExtent; retorno e.scale = function () {var n = r.apply (e, argumentos); return n === e? t? e.clipExtent (null): e: n}, e.translate = function () {var n = i.apply (e, argumentos); retorno n = == e? t? e.clipExtent (null): e: n}, e.clipExtent = funï¿½o (n) {var o = u.apply (e, argumentos); if (o === e) {if ( t = null == n) {var a = Fo * r (), l = i (); u ([[l [0] -a, l [1] -a],[l [0] + a, l [1] + a]])}} mais t && (o = null); retorne o}, e.clipExtent (null)} função Ae (n, t) {return [Math. log (Math.tan (Fo / 4 + t / 2)), - n]} função Ce (n) {retorno n [0]} função ze (n) {retorno n [1]} função Le (n) { para (var t = n.length, e = [0,1], r = 2, i = 2; t> i; i ++) {para (; r> 1 && Q (n [e [r-2]], n [e [r-1]], n [i]) <= 0;) - r; e [r ++] = i} retorna e.slice (0, r)} função qe (n, t) {retorno n Função [0] -t [0] || n [1] -t [1]} Te (n, t, e) {retorno (e [0] -t [0]) * (n [1] -t [1]) Função <(e [1] -t [1]) * (n [0] -t [0])} Re (n, t, e, r) {var i = n [0], u = e [0], o = t [0] -i, a = r [0] -u, l = n [1], c = e [1], f = t [1] -l, s = r [1] -c, h = (a * (lc) -s * (iu)) / (s * oa * f); retorno [i + h * o, l + h * f]} função De (n) {var t = n [0], e = n [n.length-1]; retorno! (t [0] -e [0] || t [1] -e [1])} função Pe () { rr (this), this.edge = this.site = this.circle = null} função Ue (n) {var t = cl.pop () || new Pe; retorno t.site = n, t} função je ( n) {Seja (n), ol.remove (n), cl.push (n), rr (n)} função Fe (n) {var t = n.círculo, e = tx, r = t.cy, i = {x: e, y: r}, u = nP, o = nN, a = [n]; je (n), para (var l = u; l.circle && xo (el.circle.x) <Uo && xo (rl.circle.cy) <Uo;) u = lP, a.unshift (l), je (l), l = u; a.unshift (l), Be (l), para (var c = o; c.circle && xo (ec.circle.x) <Uo && xo (rc.circle.cy) <Uo;) o = cN, a.push (c), je (c) , c =, a.push (c), Be (c), var f, s = comprimento a, para (f = 1; s> f; ++ f) c = a [f], l = a [f-1], nr (c.edge, l.site, c.site, i), l = a [0], c = a [s-1], c.edge = Ke (l.site, c .site, null, i), $ e (l), $ e (c)} função He (n) {para (var t, e, r, i, u = nx, o = ny, a = ol._ ; a;) se (r = Oe (a, o) -u, r> Uo) a = aL; mais {se (i = u-Ie (a, o),! (i> Uo)) {r> -U (t = aP, e = a): i> -Uo (t = a, e = aN): t = e = a; quebra} se (! AR) {t = a; quebra} a = aR} var l = Ue (n); if (ol.insert (t, l), t || e) {se (t === e) retornar Be (t), e = Ue (t.site), ol.insert (l, e), l.edge = e.edge = Ke (t.site, l.site), $ e (t), void $ e (e); if (! e) return void (l .edge = Ke (t.site, l.site)); Be (t), Be (e); var c = t.site, f = c.x, s = cy, h = nx-f, p = ny-s, g = e.site, v = gx-f, d = gy-s, y = 2 * (h * dp * v), m = h * h + p * p, M = v * v + d * d, x = {x: (d * pf * M) / y + f, y: (h * Mv * m) / y + s}; nr (e.edge, c, g, x), l.edge = Ke (c, n, nulo, x), e.edge = Ke (n, g, nulo, x), $ e (t), $ e (e)}} função Oe (n, t) {var e = n.site, r = ex, i = ey, u = it; if (! u) return r; var o = nP; if (! o ) return- (1/0); e = o.site; var a = ex, l = ey, c = lt; if (! c) return a; var f = ar, s = 1 / u-1 / c , h = f / c; retorno s? (- h + Math.sqrt (h * h-2 * s * (f * f / (- 2 * c) -l + c / 2 + iu / 2))) Função / s + r: (r + a) / 2} Ie (n, t) {var e = nN; se (e) retorna Oe (e, t); var r = n.site; retorno ry === t? rx: 1/0} função Ye (n) {this.site = n, this.edges = []} função Ze (n) {para (var t, e, r, i, u, o, a, l, c, f, s = n [0] [0], h = n [1] [0], p = n [0] [1], g = n [1] [1], v = d = v.length; d -;) se (u = v [d], u && u.prepare ()) para (a = u.edges, l = a.length, o = 0; l> o;) f = a [o] .end (), r = fx, i = fy, c = a [+ + o% l] .start (), t = cx, e = cy, (xo (rt)> Uo || xo (isto é)> Uo) && (a.splice (o, 0, new tr) (Qe (u.site, f,xo (rs) <Uo & g-i> Uo? {x: s, y: xo (ts) <Uo? e: g}: xo (ig) <Uo && h-r> Uo? {x: xo (por exemplo) <Uo t: h, y: g}: xo (rh) <Uo && i-p> Uo? {x: h, y: xo (th) <Uo? e: p}: xo (ip) <Uo & u r-s> Uo ? {x: xo (ep) <Uo? t: s, y: p}: nulo), u.site, nulo)), ++ l)} função Ve (n, t) {retorno t.angle-n .angle} function Xe () {rr (this), this.x = this.y = this.arc = this.site = this.cy = null} função $ e (n) {var t = nP, e = nN ; if (t && e) {var r = t.site, i = n.site, u = e.site; if (r! ==) {var o = ix, a = iy, l = rx-o, c = ry-a, f = ux-o, s = uy-a, h = 2 * (l * sc * f); se (! (h> = - jo)) {var p = l * l + c * c, g = f * f + s * s, v = (s * pc * g) / h, d = (l * gf * p) /h,s=d+a,y=fl.pop () | | novo Xe; y.arc = n, y.site = i, yx = v + o, yy = s + Math.sqrt (v * v + d * d), y.cy = s, n.circle = y ; para (var m = nulo, M = ll ._; M;) se (yy <Meu || aa === Meu && y.x <= Mx) {if (! ML) {m = MP; quebra} M = ML} else {se (! MR) {m = M; quebra} M = MR} ll.insert (m, y),m || (al = y)}}}} function Seja (n) {var t = n.circulo; t && (tP || (al = tN), ll.remove (t), fl.push (t), função rr (t), n.circle = null}} Nós (n) {para (var t, e = il, r = Yt (n [0] [0], n [0] [1], n [1 ] [0], n [1] [1]), i = e.length; i -;) t = e [i], (! Je (t, n) ||! R (t) || xo (tax-tbx) <Uo && xo (tay-tby) <Uo) && (ta = tb = null, e.splice (i, 1))} função Je (n, t) {var e = nb; if (e) return! 0; var r, i, u = na, o = t [0] [0], a = t [1] [0], l = t [0] [1], c = t [1] [ 1], f = nl, s = nr, h = fx, p = fy, g = sx, v = sy, d = (h + g) / 2, y = (p + v) / 2; === p) {if (o> d || d> = a) return; if (h> g) {se (u) {if (uy> = c) retorna} mais u = {x: d, y : l}; e = {x: d, y: c}} else {if (u) {if (ui <l) return} mais u = {x: d, y: c}; e = {x: d , y: l}}} else if (r = (hg) / (vp), i = yr * d, -1> r || r> 1) se (h> g) {se (u) {se ( uy> = c) return} mais u = {x: (li) / r, y: l}; e = {x: (ci) / r, y: c}} mais {if (u) {if (uy <l) return} senão u = {x: (ci) / r, y: c}; e = {x: (li) / r, y: l}} else if (v> p) {se (u) {if (ux>= a) return} senão u = {x: o, y: r * o + i}; e = {x: a, y: r * a + i}} mais {if (u) {if (ux <o ) return} else u = {x: a, y: r * a + i}; e = {x: o, y: r * o + i}} retornam na função = n, u, nb = e,! 0} Ge (n, t) {this.l = n, this.r = t, this.a = this.b = null} função Ke (n, t, e, r) {var i = novo Ge (n, t) ; retorna il.push (i), e && nr (i, n, t, e), r && nr (i, t, n, r), ul [ni] .edges.push (novo tr (i, n, t)) , ul [ti] .edges.push (novo tr (i, t, n)), i} função Qe (n, t, e) {var r = novo Ge (n, nulo); retorno ra = t, rb = e, il.push (r), r} função nr (n, t, e, r) {na || nb? nl === e? nb = r: na = r: (na = r, nl = t, nr = e)} função tr (n, t, e) {var r = n, i = nb; this.edge = n, this.site = t, this.angle = e? Math.atan2 (ey- ty, ex-tx): nl === t? Math.atan2 (ix-rx, ry-iy): Math.atan2 (rx-ix, iy-ry)} função er () {isto. = nulo} função rr (n) {nU = nC = nL = nR = nP = nN = nula} função ir (n, t) {var e = t, r = tR, i = eU; i? iL === e? iL = r: iR = r: n. = r, rU = i, eU = r, eR = rL, eR && (eRU = e), r.L = e} função ur (n, t) {var e = t, r = tL, i = eU; i? IL === e? IL = r: iR = r: n. = R, rU = i , eU = r, eL = rR, eL && (eLU = e), rR = e} function ou (n) {para (; nL;) n = nL; retorno n} função ar (n, t) {var e, r, i, u = n.sort (lr) .pop (); para (il = [], ul = new Matriz (n.length), ol = nova er, ll = nova er ;;) se (i = al, u && (! i || uy <iy || uy === iy && u.x <ix)) ux === e && u.y === r || (ul [ui] = novo Ye (u), He (u), e = ux, r = uy), u = n.pop (); ou {if (! i) quebra; Fe (i.arc)} t && (Nós (t), Ze (t)); var o = {células: ul, arestas: il}; retorno ol = ll = il = ul = nulo, o} função lr (n, t) {retorno ty-ny || tx-nx} função cr (n, t e) {return (nx-ex) * (ty-ny) - (nx-tx) * (ey-ny)} função fr (n) {retorno nx} função sr (n) {retorno ny} função hr ( ) {return {folha:! 0, nós: [], ponto: nulo, x: nulo, y: nulo}} função pr (n, t, e, r, i, u) {se (! n (t, e, r, i, u)) {var o = .5 * (e + i), a = .5 * (r + u), l = t.nodes; l [0] && pr (n, l [0 ], e, r, o, a), l [1] && pr (n,l [1], o, r, i, a), l [2] && pr (n, l [2], e, a, o, u), l [3] && pr (n, l [3], o , a, i, u)}} função gr (n, t, e, r, i, u, o) {var a, l = 1/0; função de retorno c (n, f, s, h, p) {if (! (f> u || s> o || r> h || i> p)) {se (g = n.point) {var g, v = tn.x, d = en.y, y = v * v + d * d; se (l> y) {var m = Math.sqrt (l = y); r = tm, i = em, u = t + m, o = e + m, a = g}} para (var M = n.nodes, x = .5 * (f + h), b = .5 * (s + p), _ = t> = x, w = e> = b, S = w << 1 | _, k = S + 4; k> S; ++ S) se (n = M [3 & S]) mudar (3 & S) {caso 0: c (n, f, s, x, b ); quebra; caso 1: c (n, x, s, h, b); quebra; caso 2: c (n, f, b, x, p); quebra; caso 3: c (n, x, b , h, p)}}} (n, r, i, u, o), a} função vr (n, t) {n = ao.rgb (n), t = ao.rgb (t); var e = nr, r = ng, i = nb, u = tr-e, o = tg-r, a = tb-i; função de retorno (n) {retorno "#" + bn (Math.round (e + u *) n)) + bn (Math.round (r + o * n)) + bn (Math.round (i + a * n))}} função dr (n, t) {var e, r = {}, i = {}; para (e em n) e em t r [e] = Mr (n [e], t [e]): i [e] = n [e]; para (e em t) e em n || (i [e] = t [e]);função de retorno (n) {para (e em r) i [e] = r [e] (n); retorno i}} função ano (n, t) {retorno n = + n, t = + t, função ( e) {return n * (1-e) + t * e}} function mr (n, t) {var e, r, i, u = hl.lastIndex = pl.lastIndex = 0, o = -1, a = [], l = []; para (n + = "", t + = ""; (e = hl.exec (n)) && (r = pl.exec (t));) (i = r.index )> u && (i = t.slice (u, i), a [o] a [o] + = i: a [++ o] = i), (e = e [0]) === ( r = r [0])? a [o]? a [o] + = r: a [++ o] = r: (a [++ o] = nulo, l.push ({i: o, x : yr (e, r)})), u = pl.lastIndex; retorno u <t.length && (i = t.slice (u), a [o] a [o] + = i: a [+ + o] = i), a.length <2? l [0]? (t = l [0] .x, funo (n) {retorno t (n) + ""}): funo () {retorno t} : (t = l.length, função (n) {para (var e, r = 0; t> r; ++ r) a [(e = l [r]) i] = ex (n); a.join ("")})} function Mr (n, t) {para (var e, r = ao.interpolators.length; - r> = 0 &&! (e = ao.interpolators [r] (n, t));); return e} função xr (n, t) {var e, r = [], i = [], u = n.length, o = t.length, a = Math.min (n.length, t.length), para (e = 0; a> e; ++ e) r.push (Mr (n [e], t [e])), para (; u> e; ++ e) i [e] = n [e]; para (; o> e; ++ e) i [e] = t [e]; função de retorno (n) {para (e = 0; a> e ; ++ e) i [e] = r [e] (n); retorno i}} funç˜ao br (n) {funç˜ao return (t) {return 0> = t? 0: t> = 1? 1: n (t)}} function _r (n) {função return (t) {função return 1-n (1-t)}} wr (n) {função return (t) {return.5 * (. 5> t? n (2 * t): 2-n (2-2 * t))}} função Sr (n) {retorno n * n} função kr (n) {retorno n * n * n} função Nr (n) { if (0> = n) retorna 0; se (n> = 1) retorna 1; var t = n * n, e = t * n; retorna 4 * (. 5> n e: 3 * (nt) + e-.75)} function Er (n) {função return (t) {return Math.pow (t, n)}} função Ar (n) {retorno 1-Math.cos (n * Io)} função Cr ( n) {return Math.pow (2,10 * (n-1))} função zr (n) {retorno 1-Math.sqrt (1-n * n)} função Lr (n, t) {var e; return arguments.length <2 && (t = .45), arguments.length? e = t / Ho * Math.asin (1 / n): (n = 1, e = t / 4), função (r) {retorno 1 + n * Math.pow (2,-10 * r) * Math.sin ((re) * Ho / t)}} função qr (n) {retorno n || (n = 1.70158), função (t) {retorno t * t * ((n + 1) * tn)}} funï¿½o Tr (n) {retorno 1 / 2,75> n? 7,5625 * n * n: 2 / 2,75> n? 7,5625 * (n = 1,5 / 2,75) * n + 0,75: 2,5 / 2,75 > n? 7,5625 * (n = 2,25 / 2,75) * n + .9375: 7,5625 * (n = 2,625 / 2,75) * n + 0,984375} funï¿½o Rr (n, t) {n = ao.hcl (n), t = ao.hcl (t); var e = nh, r = nc, i = nl, u = th-e, o = tc-r, a = tl-i; retorno éNaN (o) && (o = 0 , r = éNaN (r)? tc: r), éNaN (u)? (u = 0, e = éNaN (e)? th: e): u> 180? u- = 360: -180> u && (u + = 360), função (n) {return sn (+ u * n, r + o * n, i + a * n) + ""}} função Dr (n, t) {n = ao.hsl (n ), t = ao.hsl (t); var e = nh, r = ns, i = nl, u = th-e, o = ts-r, a = tl-i; retorno éNaN (o) && (o = 0, r = éNaN (r)? Ts: r), éNaN (u)? (U = 0, e = éNaN (e)? Th: e): u> 180? U- = 360: -180> u && (u + = 360), função (n) {return cn (e + u * n, r + o * n, i + a * n) + ""}} função Pr (n, t) {n = ao.lab (n), t = ao.lab (t); var e = nl, r = nd, i = nb,u = tl-e, o = ta-r, a = tb-i; função de retorno (n) {return pn (e + u * n, r + o * n, i + a * n) + ""}} função Ur (n, t) {retorno t- = n, função (e) {retorno Math.round (n + t * e)}} função jr (n) {var t = [na, nb], e = [ nc, nd], r = Hr (t), i = Fr (t, e), u = Hr (Ou (e, t, -i)) || 0; t [0] * e [1] <e [0] * t [1] && (t [0] * = - 1, t [1] * = - 1, r * = - 1, i * = - 1), this.rotate = (r? Matemática. atan2 (t [1], t [0]): Math.atan2 (-e [0], e [1])) * Zo, this.translate = [ne, nf], this.scale = [r, u ], this.skew = u? Math.atan2 (i, u) * Zo: 0} função Fr (n, t) {retornar n [0] * t [0] + n [1] * t [1]} função Hr (n) {var t = Math.sqrt (Fr (n, n)); retorno t && (n [0] / = t, n [1] / = t), t} função Ou (n, t, e) {return n [0] + = e * t [0], n [1] + = e * t [1], n} função Ir (n) {retorno n.length? n.pop () + " , ":" "} function Yr (n, t, e, r) {se (n [0]! == t [0] || n [1]! == t [1]) {var i = e .push ("translate (", null, ",", null, ")"); r.push ({i: i-4, x: yr (n [0], t [0])}, {i : i-2, x: yr (n [1],t [1])})} mais (t [0] || t [1]) && e.push ("traduzir (" + t + ")")} função Zr (n, t, e, r) {n! == t? (nt> 180? t + = 360: tn> 180 && (n + = 360), r.push ({i: e.push (Ir (e) + "rotacionar (", nulo, ")") - 2, x: yr (n, t)})): t && e.push (Ir (e) + "rotação (" + t + ")")} função Vr (n, t, e, r) {n! == t? r.push ({i: e.push (Ir (e) + "skewX (", nulo, ")") - 2, x: y (n, t)}): t && e.push (Ir (e ) + "skewX (" + t + ")")} função Xr (n, t, e, r) {se (n [0]! == t [0] || n [1]! == t [1 ]) {var i = e.push (Ir (e) + "escala (", null, ",", null, ")"); r.push ({i: i-4, x: y 0], t [0])}, {i: i-2, x: yr (n [1], t [1])})} mais 1 === t [0] && 1 === t [1 ] || e.push (Ir (e) + "escala (" + t + ")")} função $ r (n, t) {var e = [], r = []; return n = ao.transform ( n), t = ao.transform (t), Yr (n.translate, t.translate, e, r), Zr (n.rotate, t.rotate, e, r), Vr (n.skew, t.skew, e, r), Xr (n.scale, t.scale, e, r), n = t = nulo, função (n) {para (var t, i = -1, u = r [i] = tx (n); retorno e.join ("")}} function Br (n, t) {retorno t = (t- = n = + n) || 1 / t, função (e) {return (en) / t}} função Wr (n, t) {retorno t = (t = n = + n) || 1 / t, function (e) {return Math.max (0, Math.min (1, (en) / t))}} jt (n) {para (var t = n.source, e = n. alvo, r = Kr (t, e), i = [t]; t! == r;) t = t.parent, i.push (t), para (var u = i.length; e! == r;) i.splice (u, 0, e), e = e.parent; retorno i} função Gr (n) {para (var t = [], e = n.parent; null! = e;) t .push (n), t} função Kr (n, t) {se (n === t) retornar n; para (var e = .pus (n), n = e, e = e.parent; Gr (n), r = Gr (t), i = e.pop (), u = r.pop (), o = nulo; i === u;) o = i, i = e.pop () , u = r.pop (); retorno o} função Qr (n) {n.fixed | = 2} função ni (n) {n.fixed & = - 7} função ti (n) {n.fixed | = 4 , n.px = nx, n.py = ny} função ei (n) {n.fixed & = - 5} função ri (n, t, e) {var r = 0, i = 0; if (n.carga = 0,! N.folha) para (var u, o = n.nodes, a = o.length, l = -1; ++ l <a;) u = o [l], nulo! = u && (ri (u, t, e ), n.carga + = u.carga, r + = u.carga * u.cx, i + = u.carga * u.cy); if (n.point) {n.leaf || (n.point.x + = Math.random () -. 5, n.point.y + = Math.random () -. 5); var c = t * e [n.point.index]; n.charge + = n.pointCharge = c, r + = c * n.point.x, i + = c * n.point.y} n.cx = r / n.carga, n.cy = i / n.carga} função ii (n, t) {retorno ao. religar (n, t, "classificar", "filhos", "valor"), n.nodes = n, n.links = fi, n} funç˜ao ui (n, t) {para (var e = [n]; null! = (n = e.pop ());) if (t (n), (i = n.children) && (r = i.length)) para (var r, i; - r> = 0 ;) e.push (i [r])} função oi (n, t) {para (var e = [n], r = []; nulo! = (n = e.pop ());) se ( r.push (n), (u = n.children) && (i = u.length)) para (var i, u, o = -1; ++ o <i;) e.push (u [o] ); para (; null! = (n = r.pop ());) t (n)} função ai (n) {retorno n.children} função li (n) {retorno n.value} função ci (n t) {return t.value-n.value} function fi (n) {return ao.merge (n.map (função (n) {return (n.children || []). map (função (t) {retorno {origem: n, destino: t} })}))} função si (n) {retorno nx} função hi (n) {retorno ny} função pi (n, t, e) {n.y0 = t, ny = e} função gi (n) { return ao.range (n.length)} função vi (n) {para (var t = -1, e = n [0] .comprimento, r = []; ++ t <e;) r [t] = 0; return r} função di (n) {para (var t, e = 1, r = 0, i = n [0] [1], u = n.length; u> e; ++ e) (t = n [e] [1])> i && (r = e, i = t); retorno r} função yi (n) {retorno n.reduzir (mi, 0)} função mi (n, t) {retorno n + t [1]} function Mi (n, t) {return xi (n, Math.ceil (Math.log (t.length) /Mat.LN2+1))} função xi (n, t) {para ( var e = -1, r = + n [0], i = (n [1] -r) / t, u = []; ++ e <= t;) u [e] = i * e + r ; retorno u} função bi (n) {retorno [ao.min (n), ao.max (n)]} função _i (n, t) {retorno n.value-t.value} função wi (n, t ) {var e = n._pack_next; n.packpack =, t.packpackprev = n, t.pack_next = e, e_pack_prev = t} function Si (n, t) {n._pack_next = t, t._pack_prev = n} função ki (n, t) {var e = tx-nx, r = ty-ny, i = n.r + tr; retorno.999 * i * i> e * e + r * r} função Ni (n) {função t (n) {f = Math.min (nx-nr, f), s = Math.max (n.x + nr, s), h = Math.min (ny-nr, h), p = Math.max (n.y + nr, p)} se ((e = n.children) && (c = e.length)) {var e, r, i, u , o, a, l, c, f = 1/0, s = - (1/0), h = 1/0, p = - (1/0); se (e.forEach (Ei), r = e [0], rx = -rr, ry = 0, t (r), c> 1 && (i = e [1], ix = ir, iy = 0, t (i), c> 2)) para ( u = e [2], zi (r, i, u), t (u), wi (r, u), r._pack_prev = u, wi (u, i), i = r._pack_next, o = 3 ; c> o; o ++) {zi (r, i, u = e [o]); var g = 0, v = 1, d = 1; para (a = i._pack_next; a! == i; a = a._pack_next, v ++) if (ki (a, u)) {g = 1; quebra} if (1 == g) para (l = r._pack_prev; l! == a._pack_prev &&! ki (l, u); l = l._pack_prev, d ++); g? (d> v || v == d && i.r <rr? Si (r, i = a): Si (r = l, i), o-- ): (wi (r, u), i = u, t (u))} var y = (f + s) / 2, m = (h + p) / 2, M = 0; para (o = 0 ; c> o; o ++) u = e [o], ux- = y, uy- = m, M = Math.max (M, u.r + Math.sqrt (ux * u.x + u.y * uy)); nr = M, e.forEach (Ai)}} função Ei (n) {n._pack_next = n._pack_prev = n} função Ai (n) {excluir n._pack_next, excluir n._pack_prev} função Ci (n, t, e, r) {var i = n.children; se (nx = t + = r * nx, ny = e + = r * ny, nr * = r, i) para (var u = - 1, o = i.length; ++ u <o;) Ci (i [u], t, e, r)} função zi (n, t, e) {var r = n.r + er, i = tx-nx, u = ty-ny; if (r && (i || u)) {var o = t.r + er, a = i * i + u * u; o * = o, r * = r; var l = .5 + (ro) / (2 * a), c = Math.sqrt (Math.max (0,2 * o * (r + a) - (r- = a) * ro * o)) /(2*a);ex=n.x+l*i+c*u,ey=n.y+l*uc*i}else ex = n.x + r, ey = ny} função Li (n , t) {return n.parent == t.parent? 1: 2} função qi (n) {var t = n.children; retorno t.length? t [0]: nt} função Ti (n) {var t, e = n.children; retorno (t = e.length)? e [t-1]: nt} função Ri (n, t, e) {var r = e / (ti-ni); tc- = r, t.s + = e, n.c + = r, t.z + = e, t.m + = e} função Di (n) {para (var t, e = 0, r = 0, i = n.children , u = i.length; - u> = 0;) t = i [u], t.z + = e, t.m + = e, e + = t.s + (r + = tc)} função Pi (n, te) {return naparent === Função t.parent? na: e} Ui (n) {retorno 1 + ao.max (n, função (n) {retorno ny})} função ji (n) {return n. reduzir (função (n, t) {retorno n + tx}, 0) / n.length} função Fi (n) {var t = n.children; retorno t && t.length? Fi (t [0]): n} função Oi (n) {var t, e = n.children; retorno e && (t = e.length)? Oi (e [t-1]): n} função Oi (n) {return {x: nx, y : ny, dx: n.dx, dy: n.dy}} função Ii (n, t) {var e = n.x + t [3], r = n.y + t [0], i = n .dx-t [1] -t [3], u = n.dy-t [0] -t [2]; retorno 0> i && (e + = i / 2, i = 0), 0> u && (r + = u / 2, u = 0), {x: e, y: r, dx: i, dy: u}} função Yi (n) {var = n [0], e = n [n.length- 1]; return e> t? [T, e]: [e, t]} função Zi (n) {retorno n.rangeExtent? N.rangeExtent (): Yi (n.range ())} função Vi (n , t, e, r) {var i = e (n [0], n [1]), u = r (t [0], t [1]); função de retorno (n) {retorno u (i n))}} função Xi (n, t) {var e, r = 0, i = n.length-1, u = n [r], o = n [i]; retorno u> o && (e = r , r = i, i = e, e = u, u = o, o = e),n [r] = t.floor (u), n [i] = t.ceil (o), n} função $ i (n) {retornar n? {andar: function (t) {retornar Math.floor (t / n) * n}, ceil: function (t) {retornar Math.ceil (t / n) * n}}: função Sl} Bi (n, t, e, r) {var i = [], u = [], o = 0, a = Math.min (n.length, t.length) -1; para (n [a] <n [0] && (n = n.slice (). reverse (), t = t.slice (). reverse ()); ++ o <= a;) i.push (e (n [o-1], n [o])), u.push (r (t [o- 1], t [o])); função de retorno (t) {var e = ao.bisect (n, t, 1, a) -1; retorno u [e] (i [e] (t))}} função Wi (n, t, e, r) {função i () {var i = Math.min (n.length, t.length)> 2? Bi: Vi, l = r? Wr: Br; retorno o = i (n, t, l, e), a = i (t, n, l, Mr), u} função u (n) {retorno o (n)} var o, a; retorno u.invert = função ( n) {return a (n)}, u.domínio = function (t) {return argumentos.length? (n = t.map (Número), i ()): n}, u.range = função (n) {return arguments.length? (t = n, i ()): t}, u.rangeRound = função (n) {retorno u.range (n) .interpolate (Ur)}, u.clamp = função (n) {return arguments.length? (r = n, i ()): r},u.interpolate = function (n) {return argumentos.length? (e = n, i ()): e}, u.ticks = função (t) {retorno Qi (n, t)}, u.tickFormat = função (t, e) {retornar nu (n, t, e)}, u.nice = function (t) {retornar Gi (n, t), i ()}, u.copy = função () {retornar Wi ( n, t, e, r)}, i ()} função Ji (n, t) {retorno ao.rebind (n, t, "intervalo", "rangeRound", "interpolate", "clamp")} função Gi (n, t) {retorno Xi (n, $ i (Ki (n, t) [2])), Xi (n, $ i (Ki (n, t) [2])), n} função Ki ( n, t) {n == t && (t = 10); var e = Yi (n), r = e [1] -e [0], i = Math.pow (10, Math.floor (Math.log) (r / t) / Mat.LN10)), u = t / r * i; retorno.15> = u? i * = 10: .35> = u? i * = 5:, 75> = u && (i * = 2), e [0] = Math.ceil (e [0] / i) * i, e [1] = Math.floor (e [1] / i) * i + .5 * i, e [2 ] = i, e} função Qi (n, t) {retorno ao.range.apply (ao, Ki (n, t))} função nu (n, t, e) {var r = Ki (n, t) ; if (e) {var i = ha.exec (e); se (i.shift (), "s" === i [8]) {var u = ao.formatPrefix (Math.max (xo [0]), xo (r [1])));return i [7] || (i [7] = "." + tu (u.scale (r [2]))), i [8] = "f", e = ao.format (i.join ( "")), function (n) {return e (escala (n)) + u.symbol}} i [7] || (i [7] = "." + eu (i [8], r )), e = i.join ("")} mais e = ",." + tu (r [2]) + "f"; retorno ao.format (e)} function tu (n) {return-Math .floor (Math.log (n) /Matriz.LN10+.01)} função eu (n, t) {var e = tu (t [2]); retorno n em kl? Math.abs (e-tu (Math) .max (xo (t [0]), xo (t [1])))) + + ("e"! == n): e-2 * ("%" === n)} fun n, t, e, r) {função i (n) {return (e? Math.log (0> n? 0: n): - Math.log (n> 0? 0: -n)) / Math. log (t)} função u (n) {return e? Math.pow (t, n): - Math.pow (t, -n)} função o (t) {retorno n (i (t))} retorno o.invert = função (t) {retorno u (n.invert (t))}, o.domínio = função (t) {return argumentos.length? (e = t [0]> = 0, n.domínio ( (r = t.map (Número)) map (i)), o): r}, o.base = função (e) {return arguments.length? (t = + e, n.domínio (r.map (i)), o): t}, o.nice = função () {var t = Xi (r.map (i), e? Matemática: El); retorno n.domínio (t) , r = t.map (u), o}, o.ticks = função () {var n = Yi (r), o = [], a = n [0], l = n [1], c = Math.floor (i (a)), f = Math.ceil (i (l)), s = t% 1? 2: t; if (isFinite (fc)) {se (e) {para (; f> c; c ++) para (var h = 1; s> h; h ++) o.push (u (c) * h); o.push (u (c))} mais para (o.push (u (c) ); c ++ <f;) para (var h = s-1; h> 0; h -) o.push (u (c) * h); para (c = 0; o [c] <a; c ++ ) para (f = o.length; o [f-1]> l; f -); o = o.slice (c, f)} retorno o}, o.tickFormat = function (n, e) { if (! arguments.length) return Nl; argumentos.length <2? e = Nl: "função"! = tipo de e && (e = ao.format (e)); var r = Math.max (1, t * n /o.ticks().length);return function (n) {var = n / u (Math.round (i (n))); retorno t -.5> o * t && (o * = t), r = = o? e (n): ""}}, o.copy = função () {retorno ru (n.copy (), t, e, r)}, Ji (o, n)} função iu ( n, t, e) {função r (t) {retorno n (i (t))} var i = uu (t), u = uu (1 / t);return r.invert = função (t) {retorno u (n.invert (t))}, r.domínio = função (t) {retorno arguments.length? (n.domain ((e = t.map (Number) ) .map (i)), r): e}, r.ticks = função (n) {retorno Qi (e, n)}, r.tickFormat = função (n, t) {return nu (e, n, t)}, r.nice = function (n) {return r.domain (Gi (e, n))}, r.exponente = function (o) {retorno arguments.length? (i = uu (t = o) , u = uu (1 / t), n.dominio (e.map (i)), r): t}, r.copy = funo () {retorno iu (n.copy (), t, e)} , Função ji (r, n)} uu (n) {função return (t) {retorno 0> t? -Math.pow (-t, n): Math.pow (t, n)}} função ou (n , t) {função e (e) {retorno u [((i.get (e) || ("intervalo" === tt? i.set (e, n.push (e)): NaN)) - 1)% u.length]} função r (t, e) {retorno ao.range (n.length) .map (função (n) {retorno t + e * n})} var i, u, o; e.domain = function (r) {if (! argumentos.length) retorna n; n = [], i = novo c; para (var u, o = -1, a = comprimento_l; ++ o <a ;) i.has (u = r [o]) || i.set (u, n.push (u)); retorno e [tt] .apply (e, ta)}, e.range = function (n) {return argumentos.length? (u = n, o = 0, t = {t: "intervalo", a: argumentos}, e): u}, e.rangePoints = função (i, a ) {arguments.length <2 && (a = 0); var l = i [0], c = i [1], f = n.length <2? (l = (l + c) / 2,0): (cl) / (n.length-1 + a); retorno u = r (l + f * a / 2, f), o = 0, t = {t: "rangePoints", a: argumentos}, e} , e.rangeRoundPoints = função (i, a) {argumentos.length <2 && (a = 0); var l = i [0], c = i [1], f = n.length <2? (l = c = Math.round ((l + c) / 2), 0) :( cl) / (n.length-1 + a) | 0; retorno u = r (l + Math.round (f * a / 2 + (cl- (n.length-1 + a) * f) / 2), f), o = 0, t = {t: "rangeRoundPoints", a: argumentos}, e}, e.rangeBands = função (i , a, l) {argumentos.length <2 && (a = 0), arguments.length <3 && (l = a); var c = i [1] <i [0], f = i [c-0], s = i [1-c], h = (sf) / (n.length-a + 2 * l); retorno u = r (f + h * l, h), c & u.reverse (), o = h * (1-a), t = {t: "rangeBands", a: argumentos}, e}, e.rangeRoundBands = função (i, a,l) {arguments.length <2 && (a = 0), arguments.length <3 && (l = a); var c = i [1] <i [0], f = i [c-0], s = i [1-c], h = Math.floor ((sf) / (n.length-a + 2 * l)); retorno u = r (f + Math.round ((sf- (n.length-a) * h) / 2), h), c & u.reverse (), o = Math.round (h * (1-a)), t = {t: "rangeRoundBands", a: argumentos}, e}, e. rangeBand = function () {retornar o}, e.rangeExtent = function () {retornar Yi (ta [0])}, e.copy = função () {retorno ou (n, t)}, e.domain (n )} função au (n, t) {função u () {var e = 0, r = t.length; para (a = []; ++ e <r;) a [e-1] = ao.quantile (n, e / r); return o} função o (n) {return éNaN (n = + n)? void 0: t [ao.bisect (a, n)]} var a; retorno o.domínio = função (t) {return arguments.length? (n = t.map (r) .filter (i) .sort (e), u ()): n}, o.range = função (n) {return argumentos.length ? (t = n, u ()): t}, o.quantiles = função () {return a}, o.invertExtent = função (e) {return e = t.indexOf (e), 0> e? [ NaN, NaN]: [e> 0? A [e-1]: n [0], e <a.length? a [e]: n [n.length-1]]}, o.copy = função () {retorno au (n, t)}, u ()} função lu (n, t, e) {função r (t) {return e [Math.max (0, Math.min (o, Math.floor (u * (tn)))]}} função i () {retorno u = e.length / (tn), o = e.length-1, r} var u, o; return r.domain = function (e) {retornar argumentos.length? (n = + e [0], t = + e [comprimento_length-1] , i ()): [n, t]}, r.range = função (n) {return argumentos.length? (e = n, i ()): e}, r.invertExtent = função (t) {retorno t = e.indexOf (t), t = 0> tNaN: t / u + n, [t, t + 1 / u]}, r.copy = funç˜ao () {return lu (n, t, e )}, i ()} função cu (n, t) {função e (e) {retorno e> = e? t [ao.bisect (n, e)]: void 0} return e.domain = function (t ) {return arguments.length? (n = t, e): n}, e.range = função (n) {return argumentos.length? (t = n, e): t}, e.invertExtent = função (e ) {return e = t.indexOf (e), [n [e-1], n [e]]}, e.copy = função () {retorno cu (n, t)}, e} função fu (n ) {função t (n) {retorno + n} retorno t.invert = t, t.domain = t.range = function (e) {return argumentos.length? (n = e.map (t), t): n}, t.ticks = função (t) {retorno Qi (n, t)}, t.tickFormat = função (t, e) {retornar nu (n, t, e)}, t.copy = função () {retorno fu (n)}, t} função su () {retorno 0} função hu (n) {retorno n.innerRadius} função pu (n) {retorno n.outerRadius} função gu (n) {retorno n.startAngle} função vu (n) {retorno n.endAngle} função du (n) {retorno n && n.padAngle} função yu (n, t, e, r) {retorno (ne) * t- (tr) * n> 0 0: 1} função mu (n, t, e, r, i) {var u = n [0] -t [0], o = n [1] -t [1], a = (i? r: -r) /Matriz.sqrt (u * u + o * o), l = a * o, c = -a * u, f = n [0] + l, s = n [1] + c, h = t [0] + l, p = t [1] + c, g = (f + h) / 2 , v = (s + p) / 2, d = hf, y = ps, m = d * d + y * y, M = er, x = f * ph * s, b = (0> y -1 -1 : 1) * Math.sqrt (Math.max (0, M * M * mx * x)), _ = (x * yd * b) / m, w = (- x * dy * b) / m, S = (x * y + d * b) / m, k = (- x * d + y * b) / m, N = _- g, E = wv, A = Sg, C = kv; retorno N * N + E * E> A * A + C * C && (_ = S, w = k), [[_- l, wc], [_ * e / M,w * e / M]]} função Mu (n) {função t (t) {função o () {c.push ("M", u (n (f), a))} para (var l, c = [], f = [], s = -1, h = t.length, p = En (e), g = En (r); ++ s <h;) i.call (isto, l = t [s], s)? f.push ([+ p.call (isto, l, s), + g.call (isto, l, s)]): f.length && (o (), f = [] ); return f.length && o (), c.length? c.join (""): null} var e = Ce, r = ze, i = zt, u = xu, o = u.key, a = .7 return tx = function (n) {return argumentos.length? (e = n, t): e}, ty = função (n) {return argumentos.length? (r = n, t): r}, t. define = function (n) {return argumentos.length? (i = n, t): i}, t.interpolate = função (n) {return argumentos.length? (o = "função" == tipoof n? u = n: (u = Tl.get (n) || xu) .chave, t): o}, t.tensão = função (n) {return argumentos.length? (a = n, t): a}, t } função xu (n) {retornar n.length> 1? n.join ("L"): n + "Z"} função bu (n) {retorno n.join ("L") + "Z"} função _u (n) {para (var t = 0, e = n.length, r = n [0],i = [r [0], ",", r [1]]; ++ t <e;) i.push ("H", (r [0] + (r = n [t]) [0] ) / 2, "V", r [1]); return e> 1 && i.push ("H", r [0]), i.join ("")} funcao wu (n) {para (var t = 0, e = n.length, r = n [0], i = [r [0], ",", r [1]]; ++ t <e;) i.push ("V", (r = n [t]) [1], "H", r [0]); retorno i.join ("")} função Su (n) {para (var t = 0, e = n.length, r = n [0], i = [r [0], ",", r [1]]; ++ t <e;) i.push ("H", (r = n [t]) [0], "V", r [1]); retorno i.join ("")} função ku (n, t) {retorno n.length <4? Xu (n): n [1] + Au (n.slice ( 1, -1), Cu (n, t))} função Nu (n, t) {retorno n.length <3? Bu (n): n [0] + Au ((n.push (n [0] ), n), Cu ([n [n.length-2]]. concat (n, [n [1]]), t))} função Eu (n, t) {retorno n.length <3? xu (n): n [0] + Au (n, Cu (n, t))} função Au (n, t) {se (t.length <1 || n.length! = t.length && n.length! = t.length + 2) return xu (n); var e = n.length!= t.length, r = "", i = n [0], u = n [1], o = t [0], a = o, l = 1; se (e && (r + = "Q" + ( u [0] -2 * o [0] / 3) + "," + (u [1] -2 * o [1] / 3) + "," + u [0] + "," + u [ 1], i = n [1], l = 2), t.length> 1) {a = t [1], u = n [l], l ++, r + = "C" + (i [0] + o [0]) + "," + (i [1] + o [1]) + "," + (u [0] -a [0]) + "," + (u [1] -a [ 1]) + "," + u [0] + "," + u [1]; para (var c = 2; c <t.length; c ++, l ++) u = n [l], a = t [ c], r + = "S" + (u [0] -a [0]) + "," + (u [1] -a [1]) + "," + u [0] + "," + u [1]} se (e) {var f = n [l]; r + = "Q" + (u [0] + 2 * a [0] / 3) + "," + (u [1] + 2 * a [1] / 3) + "," + f [0] + "," + f [1]} retorna r} função Cu (n, t) {para (var e, r = [], i = (1-t) / 2, u = n [0], o = n [1], a = 1, l = n.length; ++ a <l;) e = u, u = o, o = n [a], r.push ([i * (o [0] -e [0]), i * (o [1] -e [1])]); retorno r} função zu (n) {se (n.length <3) return xu (n); var t = 1, e = n.length, r = n [0], i = r [0], u = r [1],o = [i, i, i, (r = n [1]) [0]], a = [u, u, u, r [1]], l = [i, ",", u, "L ", Ru (Pl, o),", ", Ru (Pl, a)]; para (n.push (n [e-1]); ++ t <= e;) r = n [t], o.shift (), o.push (r [0]), a.shift (), a.push (r [1]), Du (l, o, a); retorno n.pop (), l. função push ("L", r), l.join ("")} Lu (n) {if (n.length <4) return xu (n); para (var t, e = [], r = - 1, i = n.length, u = [0], o = [0]; ++ r <3;) t = n [r], u.push (t [0]), o.push (t [ 1]), para (e.push (Ru (Pl, u) + "," + Ru (Pl, o)), - r; ++ r <i;) t = n [r], u.shift (), u.push (t [0]), o.shift (), o.push (t [1]), Du (e, u, o); retorno e.join ("")} function qu ( n) {para (var t, e, r = -1, i = n.length, u = i + 4, o = [], a = []; ++ r <4;) e = n [r% i], o.push (e [0]), a.push (e [1]), para (t = [Ru (Pl, o), ",", Ru (Pl, a)], - r ; ++ r <u;) e = n [r% i], o.shift (), o.push (e [0]), a.shift (), a.push (e [1]), Du (t, o, a); retorno t.join ("")} function Tu (n, t) {var e = n.length-1; if (e) para (var r, i, u = n [0 ] [0], o = n [0] [1],a = n [e] [0] -u, l = n [e] [1] -o, c = -1; ++ c <= e;) r = n [c], i = c / e, r [0] = t * r [0] + (1-t) * (u + i * a), r [1] = t * r [1] + (1-t) * (o + i * l ); retorno zu (n)} função Ru (n, t) {retorno n [0] * t [0] + n [1] * t [1] + n [2] * t [2] + n [3 ] * t [3]} funç˜ao Du (n, t, e) {n.push ("C", Ru (RI, t), ",", Ru (RI, e), ",", Ru (DL) , t), ",", Ru (Dl, e), ",", Ru (Pl, t), ",", Ru (Pl, e))} função Pu (n, t) {return (t [ 1] -n [1]) / (t [0] -n [0])} função Uu (n) {para (var t = 0, e = n.length-1, r = [], i = n [0], u = n [1], o = r [0] = Pu (i, u); ++ t <e;) r [t] = (o + (o = Pu) (i = u, u = n [t + 1]))) / 2; retorno r [t] = o, r} função ju (n) {para (var t, e, r, i, u = [], o = Uu (n) , a = -1, l = n.length-1; ++ a <l;) t = Pu (n [a], n [a + 1]), xo (t) <Uo? o [a] = o [a + 1] = 0: (e = o [a] / t, r = o [a + 1] / t, i = e * e + r * r, i> 9 && (i = 3 * t / Math.sqrt (i), o [a] = i * e, o [a + 1] = i * r)); para (a = -1; ++ a <= l;) i = (n [Math .min (l, a + 1)] [0] -n [Math.max (0, a-1)] [0]) / (6 * (1 + o [a] * o [a])), u.push ([i || 0, o [a] * i || 0]);return u} funç˜ao Fu (n) {return n.length <3? xu (n): n [0] + Au (n, ju (n))} funç˜ao Hu (n) {para (var t, e, r , i = -1, u = n.length; ++ i <u;) t = n [i], e = t [0], r = t [1] -Io, t [0] = e * Math .cos (r), t [1] = e * Math.sin (r); retorno n} função Ou (n) {função t (t) {função l () {v.push ("M", a ( n (y), s), f, c (n (inverso ()), s), "Z")} para (var h, p, g, v = [], d = [], y = [], m = -1, M = t.length, x = en (e), b = en (i), _ = e === r? function () {
return p}: En (r), w = i === u? function () {return g}: En (u); ++ m <M;) o.call (isto, h = t [m], m)? (d.push ([p = + x.call (isto, h, m), g = + b.call (isto, h, m)]), y.push ([+ _. call , h, m), + w.call (isto, h, m)])): d.length && (l (), d = [], y = []); retorno d.length && l (), v.length v.join (""): null} var e = Ce, r = Ce, i = 0, u = ze, o = zt, a = xu, l = a.key, c = a, f = "L ", s = .7; return tx = função (n) {return argumentos.length? (e = r = n, t): r}, t0 = função (n) {return arguments.length? (e = n, t): e}, t.x1 = função (n) {return argumentos.length? (r = n, t): r}, ty = função (n) {return arguments.length? (i = u = n, t): u}, t.y0 = função (n) {return argumentos.length? (i = n, t): i}, t.y1 = função (n) {return argumentos.length? (u = n, t): u}, t.defined = função (n) {return argumentos.length? (o = n, t): o}, t.interpolate = função (n) {return argumentos.length? (l = "function" == typeof n? a = n: (a = Tl.get (n) || xu) .key, c = a.reverse || a, f = a.fechado? "M": "L", t): l}, t tensão = função (n) {retorno arguments.length? (s = n, t): s}, t} função Iu (n) {return Função n.radius} Função Yu (n) {retorno [nx, ny]} Zu (n) {função return () {var t = n.apply (isto, argumentos), e = t [0], r = t [1] -Io; return [e * Math.cos (r), e * Math.sin (r)]}} função Vu () {retorno 64} função Xu () {retorno "círculo"} função $ u ( n) {var = Math.sqrt (n / Fo); retorno "M0," + t + "A" + t + "," + t + "0 1,1 0," + - t + "A" + t + ", "+ t +" 0 1,1 0, função "+ t +" Z "} Bu (n) {função de retorno () {var t, e, r; (t = isto [n]) && (r = t [e = t.active]) && (r.timer.c = null, r.timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + =. 5, r .event && r.event.interrupt.call (isto, isto .__ data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), ntensão = função (n) {retorno arguments.length? (s = n, t): s}, t} função Iu (n) {retorno n.radius} função Função de Yu (n) {return [nx, ny]} Zu (n) {função de retorno () {var t = n.apply (isto, argumentos), e = t [0], r = t [1] -Io; retorno [e * Math.cos (r), e * Math.sin (r)]}} função Vu () {return 64} função Xu () {retorno "círculo"} função $ u (n) {var = Math.sqrt (n / Fo); retorno "M0 , "+ t +" A "+ t +", "+ t +" 0 1,1 0, "+ - t +" A "+ t +", "+ t +" 0 1,1 0, função "+ t +" Z "} Bu (n) {função de retorno () {var t, e, r; (t = este [n]) && (r = t [e = t.active]) && (r.timer.c = null, r. timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + =. 5, r.event && r.event.interrupt.call (isto, este .__ data __, r.index )}} função Wu (n, t, e) {retorno ko (n, Yl), ntensão = função (n) {retorno arguments.length? (s = n, t): s}, t} função Iu (n) {retorno n.radius} função Função de Yu (n) {return [nx, ny]} Zu (n) {função de retorno () {var t = n.apply (isto, argumentos), e = t [0], r = t [1] -Io; retorno [e * Math.cos (r), e * Math.sin (r)]}} função Vu () {return 64} função Xu () {retorno "círculo"} função $ u (n) {var = Math.sqrt (n / Fo); retorno "M0 , "+ t +" A "+ t +", "+ t +" 0 1,1 0, "+ - t +" A "+ t +", "+ t +" 0 1,1 0, função "+ t +" Z "} Bu (n) {função de retorno () {var t, e, r; (t = este [n]) && (r = t [e = t.active]) && (r.timer.c = null, r. timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + =. 5, r.event && r.event.interrupt.call (isto, este .__ data __, r.index )}} função Wu (n, t, e) {retorno ko (n, Yl), nx, ny]} função Zu (n) {função return () {var t = n.apply (isto, argumentos), e = t [0], r = t [1] -Io; retorno [e * Math. função cos (r), e * Math.sin (r)]}} função Vu () {return 64} função Xu () {retorno "círculo"} $ u (n) {var t = Math.sqrt (n / Fo); retorno "M0", + t + "A" + t + "," + t + "0 1,1 0," + - t + "A" + t + "," + t + "0 1,1 0," + t + "Z"} função Bu (n) {função de retorno () {var t, e, r; (t = este [n]) && (r = t [e = t.active]) && (r.timer. c = null, r.timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + =. 5, r.event && r.event.interrupt.call (isto, este __, data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), nx, ny]} função Zu (n) {função return () {var t = n.apply (isto, argumentos), e = t [0], r = t [1] -Io; retorno [e * Math. função cos (r), e * Math.sin (r)]}} função Vu () {return 64} função Xu () {retorno "círculo"} $ u (n) {var t = Math.sqrt (n / Fo); retorno "M0", + t + "A" + t + "," + t + "0 1,1 0," + - t + "A" + t + "," + t + "0 1,1 0," + t + "Z"} função Bu (n) {função de retorno () {var t, e, r; (t = este [n]) && (r = t [e = t.active]) && (r.timer. c = null, r.timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + =. 5, r.event && r.event.interrupt.call (isto, este __, data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), n} função $ u (n) {var = Math.sqrt (n / Fo); retorno "M0" + t + "A" + t + "," + t + "0 1,1 0," + - t + "A "+ t +", "+ t +" 0 1,1 0, "+ t +" Z "} função Bu (n) {função de retorno () {var t, e, r; (t = isto [n]) && ( r = t [e = t.active]) && (r.timer.c = nulo, r.timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + = .5, r.event && r.event.interrupt.call (isto, isto .__ data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), n} função $ u (n) {var = Math.sqrt (n / Fo); retorno "M0" + t + "A" + t + "," + t + "0 1,1 0," + - t + "A "+ t +", "+ t +" 0 1,1 0, "+ t +" Z "} função Bu (n) {função de retorno () {var t, e, r; (t = isto [n]) && ( r = t [e = t.active]) && (r.timer.c = nulo, r.timer.t = NaN, - t.count? delete t [e]: exclua este [n], t.active + = .5, r.event && r.event.interrupt.call (isto, isto .__ data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), n__data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), n__data __, r.index))}} função Wu (n, t, e) {retorno ko (n, Yl), n.namespace = t, n.id = e, n} função Ju (n, t, e, r) {var i = n.id, u = n.namespace; retorno Y (n, "função" == typeof e Função (n, o, a) {n [u] [i] .tween.set (t, r (e.call (n, n .__ dados __, o, a)))} :( e = r (e ), função (n) {n [u] [i] .tween.set (t, e)}))} função Gu (n) {retorno nulo == n && (n = ""), function () {this .textContent = n}} função Ku (n) {retorno nulo == n? "__ transição __": "__ transição _" + n + "__"} função Qu (n, t, e, r, i) {função u (n) {var t = v.delay; retorno ft = t + l, n> = t0o (nt): void (fc = o)} função o (e) {var i = g.active, u = g [i ]; u && (u.timer.c = null, u.timer.t = NaN, - g.count, excluir g [i], u.event && u.event.interrupt.call (n, n .__ dados __, u. index)) para (var o em g) if (r> + o) {var = g [o]; c.timer.c = null, c.timer.t = NaN, - g.count, delete g [o]} fc = a, qn (função () {retorno fc && a (e || 1) && (fc = null, ft = NaN), 1}, 0, l), g.active = r, v. evento&& v.event.start.call (n, n .__ dados __, t), p = [], v.tween.forEach (função (e, r) {(r = r.call (n, n .__ dados __, t) ) && p.push (r)}), h = v.ease, s = v.duração} function a (i) {para (var u = i / s, o = h (u), a = p.length; a> 0;) p [- a] .call (n, o); retorno u> = 1? (v.event && v.event.end.call (n, n .__ dados __, t), - g.count ? delete g [r]: delete n [e], 1): void 0} var l, f, s, h, p, g = n [e] || (n [e] = {ativo: 0, contagem : 0}), v = g [r]; v || (l = i.time, f = qn (u, 0, l), v = g [r] = {tween: novo c, tempo: l, temporizador: f, atraso: i.delay, duração: i.duration, facilidade: i.ease, índice: t}, i = nulo, ++ g.count)} função não (n, t, e) {n. attr ("transformar", função (n) {var r = t (n); retornar "translate (" + (isFinite (r)? r: e (n)) + ", 0)"})} function para ( n, t, e) {n.attr ("transformar", função (n) {var r = t (n); retorno "traduzir (0," + (éFinito (r)? r: e (n)) + ")"})} function eo (n) {retorno n.toISOString ()} função ro (n, t,e) {função r (t) {retorno n (t)} função i (n, e) {var r = n [1] -n [0], i = r / e, u = ao.bisect (Kl, i); retorno u == Kl.length? [t.ano, Ki (n.map (função (n) {retorno n / 31536e6}), e) [2]]: u? t [i / Kl [u -1] <Kl [u] / i? U-1: u]: [tc, Ki (n, e) [2]]} return r.invert = função (t) {return io (n.invert (t )}, r.domain = function (t) {return argumentos.length? (n.dominio (t), r): n.dominio (). map (io)}, r.nice = funcao (n, t ) {function e (e) {return! isNaN (e) &&! n.range (e, io (+ e + 1), t) .comprimento} var u = r.domain (), o = Yi (u) , a = null == n? i (o, 10): "número" == typeof n && i (o, n); retorna a && (n = a [0], t = a [1]), r.domain ( Xi (u, t> 1? {Soalho: função (t) {para (; e (t = n.floor (t));) t = io (t-1); retorno t}, ceil: function (t ) {para (; e (t = n.ceil (t));) t = io (+ t + 1); retorno t}}: n))}, r.ticks = função (n, t) {var e = Yi (r.domain ()), u = null == n? i (e, 10): "número" == tipoof n? i (e, n):! n.range && [{intervalo: n} , retorne u && (n = u [0],t = u [1]), n.range (e [0], io (+ e [1] +1), 1> t? 1: t)}, r.tickFormat = funo () {retorno e}, r.copy = function () {return ro (n.copy (), t, e)}, Ji (r, n)} função io (n) {retornar nova data (n)} função uo (n) {return JSON.parse (n.responseText)} função oo (n) {var t = fo.createRange (); retorno t.selectNode (fo.body), t.createContextualFragment (n.responseText)} var ao = {versão: " 3.5.17 "}, lo = []. Slice, co = função (n) {return lo.call (n)}, fo = este.document; if (fo) try {co (fo.documentElement.childNodes) [ 0] .nodeType} catch (so) {co = função (n) {para (var t = n.length, e = novo Array (t); t -;) e [t] = n [t]; e}} if (Date.now || (Date.now = função () {return + new Date}), fo) tente {fo.createElement ("DIV"). style.setProperty ("opacidade", 0, " ")} catch (ho) {var po = este.Element.prototype, go = po.setAttribute, vo = po.setAttributeNS, yo = this.CSSStyleDeclaration.prototype, mo = yo.setProperty; po.setAttribute = função (n, t) {go.call (isto, n, t + "")}, po.setAttributeNS = função (n, t, e) {vo.call (isto, n, t, e + "") }, yo.setProperty = função (n, t, e) {mo.call (isto, n, t + "", e)}} ao.ascending = e, ao.descendendo = function (n, t) {return n > t? -1: t> n1: t> = n? 0: NaN}, ao.min = função (n, t) {var e, r, i = -1, u = n.length; (1 === arguments.length) {for (; ++ i <u;) if (null! = (R = n [i]) && r> = r) {e = r; quebra} para (; ++ i <u;) null! = (r = n [i]) && e> r && (e = r)} else {para (; ++ i <u;) if (null! = (r = t.call (n) , n [i], i)) && r> = r) {e = r; quebra} para (; ++ i <u;) null! = (r = t.call (n, n [i], i) ) && e> r && (e = r)} return e}, ao.max = função (n, t) {var e, r, i = -1, u = n.length; if (1 === argumentos.length ) {for (; ++ i <u;) if (null! = (r = n [i]) && r> = r) {e = r; quebra} para (; ++ i <u;) null! = (r = n [i]) && r> e && (e = r)} else {para (; ++ i <u;) if (null! = (r = t.chamada (n, n [i], i)) && r> = r) {e = r; quebra} para (; ++ i <u;) null! = (r = t.call (n, n [i] , e), ao.extent = função (n, t) {var e, r, i, u = -1, o = n.length; if (1 = == arguments.length) {para (; ++ u <o;) if (null! = (r = n [u]) && r> = r) {e = i = r; quebra} para (; ++ u <o;) null! = (r = n [u]) && (e> r && (e = r), r> i && (i = r)}} else {para (; ++ u <o;) if ( null! = (r = t.call (n, n [u], u)) && r> = r) {e = i = r; quebra} para (; ++ u <o;) null! = (r = t.call (n, n [u], u)) && (e> r && (e = r), r> i && (i = r)}} retorno [e, i]}, ao.sum = função (n , t) {var e, r = 0, u = n.length, o = -1; if (1 === argumentos.length) para (; ++ o <u;) i (e = + n [o ]) && (r + = e); else para (; ++ o <u;) i (e = + t.call (n, n [o], o)) && (r + = e); retorno r}, ao.mean = função (n, t) {var e, u = 0, o = n.length, a = -1, l = o; if (1 === argumentos.length) para (; ++ a < o;) i (e = r (n [a]))? u + = e: - l; mais para (; ++ a <o;) i (e = r (t.call (n, n [a], a)))? u + = e: - l; retorno l? u / l: void 0}, ao.quantil = funo (n, t) {var e = (n.length-1) * t + 1, r = Math.floor (e), i = + n [r-1], u = er; retorno u? i + u * (n [r] -i): i}, ao.median = função (n, t) {var u, o = [], a = n.length, l = -1; if (1 === argumentos.length) para (; ++ l <a;) i (u = r (n [l])) && o.push (u); else para (; ++ l <a;) i (u = r (t.call) n, n [l], l))) && o.push (u); retorno o.length? ao.quantile (o.sort (e), 5): void 0}, ao.variance = function (n, t) {var e, u, o = n.length, a = 0, l = 0, c = -1, f = 0; if (1 === argumentos.length) para (; ++ c <o; ) i (e = r (n [c])) && (u = ea, a + = u / ++ f, l + = u * (ea)); else para (; ++ c <o;) i (e = r (t.call (n, n [c], c))) && (u = ea, a + = u / ++ f, l + = u * (ea)); retorno f> 1? l / (f -1): void 0}, ao.deviation = function () {var n = ao.variance.apply (isto, argumentos); return n? Math.sqrt (n): n}; var Mo = u (e) ; ao.bisectLeft = Mo.left, ao.bisect = ao.bisectRight = Mo.right, ao.bisector = function (n) {retorno u (1 === n.comprimento? função (t, r) {retorno e (n (t), r)}: n)}, ao.shuffle = função (n, t, e) {(u = argumentos.length) <3 && (e = n.length, 2> u && (t = 0)), para (var r, i, u = et; u;) i = Math.random () * u-- | 0, r = n [u + t] , n [u + t] = n [i + t], n [i + t] = r; retorno n}, ao.permute = função (n, t) {para (var e = t.length, r = new Matriz (e); e -;) r [e] = n [t [e]]; retorno r}, ao.pairs = função (n) {para (var t, e = 0, r = n. length-1, i = n [0], u = novo Matriz (0> r? 0: r); r> e;) u [e] = [t = i, i = n [++ e]]; return u}, ao.transpose = function (n) {se (! (i = n.length)) return []; para (var t = -1, e = ao.min (n, o), r = novo Array (e); ++ t <e;) para (var i, u = -1, a = r [t] = novo Array (i); ++ u <i;) a [u] = n [u ] [t]; return r}, ao.zip = function () {return ao.transpose (argumentos)}, ao.keys = function (n) {var t = []; para (var e em n) t. push (e); retorno t}, ao.values ​​= função (n) {var t = []; para (var e em n) t.push (n [e]); retorno t}, ao.entries = função (n) {var t = []; para (var e em n) t.push ({chave: e, valor: n [e]});return t}, ao.merge = função (n) {para (var t, e, r, i = n.length, u = -1, o = 0; ++ u <i;) o + = n [u] .length; para (e = new Array (o); - i> = 0;) para (r = n [i], t = comprimento r;; t> = 0;) e [- o] = r [t]; return e}; var xo = Math.abs; ao.range = função (n, t, e) {if (argumentos.length <3 && (e = 1, argumentos.length <2 && (t = n, n = 0)), (tn) / e === 1/0) lançar novo Erro ("intervalo infinito"); var r, i = [], u = a (xo (e)), o = -1; if (n * = u, t * = u, e * = u, 0> e) para (; (r = n + e * ++ o)> t;) i.push (r / u) ; else para (; (r = n + e * ++ o) <t;) i.push (r / u); retorno i}, ao.map = função (n, t) {var e = novo c; if (n instanceof c) n.forEach (função (n, t) {e.set (n, t)}); else if (Array.isArray (n)) {var r, i = -1, u = n .length; if (1 === arguments.length) para (; ++ i <u;) e.set (i, n [i]); else para (; ++ i <u;) e.set ( t.call (n, r = n [i], i), r)} mais para (var o em n) e.set (o, n [o]); retorne e}; var bo = "__ proto__", _o = "\ x00"; l (c, {tem: h, obtém:function (n) {retorne isto ._ [f (n)]}, set: function (n, t) {retorne isto ._ [f (n)] = t}, remova: p, chaves: g, valores: function () {var n = []; para (var t neste ._) n.push (isso ._ [t]); return n}, entradas: function () {var n = []; para (var t neste ._) n.push ({chave: s (t), valor: isto ._ [t]}); retorno n}, tamanho: v, vazio: d, paraEach: function (n) {for ( var t neste ._) n.call (isto, s (t), isto ._ [t])}}), ao.nest = function () {função n (t, o, a) {if (a > = u.length) return rall.call (i, o): e? o.sort (e): o, para (var l, f, s, h, p = -1, g = o.length , v = u [a ++], d = novo c; ++ p <g;) (h = d.get (l = v (f = o [p])))? h.push (f): d. set (l, [f]); retorna t (f = t (), s = função (e, r) {f.set (e, n (t, r, a))}): (f = { }, s = função (e, r) {f [e] = n (t, r, a)}), d.forEach (s), f} função t (n, e) {if (e> = u (comprimento) retorno n; var r = [], i = o [e ++]; retorno n.forCada (função (n, i) {r.push ({chave: n, valores: t (i, e)}) }), i? r.sort (função (n, t) {return i (n.key, t.key)}): r} var e, r, i = {}, u = [], o = [ ]; retorno i.map = function (t, e) {retornar n (e, t, 0)}, i.entries = função (e) {retornar t (n (ao.map, e, 0), 0)}, i.key = função (n) {retorno u.push (n), i}, i.sortKeys = função (n) {retorno o [u.length-1] = n, i}, i.sortValues ​​= função (n) { return e = n, i}, i.rollup = função (n) {retorno r = n, i}, i}, ao.set = função (n) {var t = novo y; if (n) para (var e = 0, r = n.length, r> e; ++ e) t.add (n [e]); retorno t}, l (y, {tem: h, adiciona: function (n) {retorne este ._ [f (n + = "")] =! 0, n}, remove: p, valores: g, tamanho: v, vazio: d, paraEach: function (n) {para (var t neste._) n.call (this, s (t))}}), ao.behavior = {}, ao.rebind = function (n, t) {para (var e, r = 1, i = arguments.length; ++ r <i;) n [e = argumentos [r]] = M (n, t, t [e]); retorno n}; var wo = ["webkit", "ms", "moz", "Moz" , "o", "O"]; ao.dispatch = function () {para (var n = novo _, t = -1, e = argumentos.length; ++ t <e;) n [argumentos [t] ] = w (n); retorno n}, _. prototype.on = function (n,t) {var e = n.indexOf ("."), r = ""; se (e> = 0 && (r = n.slice (e + 1), n ​​= n.slice (0, e)), n) retorna arguments.length <2? this [n] .on (r): isto [n] .on (r, t); if (2 === argumentos.length) {if (null == t) para (n neste) this.hasOwnProperty (n) && this [n] .on (r, null); retorne isto}}, ao.event = null, ao.requote = função (n) {return n.replace (Então, "\\ $ &")}; .__ proto __? função (n, t) {n .__ proto __ = t}: função (n, t) {para (var e em t) n [e] = t [e]}, Não = função (n, t) {return t.querySelector (n)}, Eo = função (n, t) {retorno t.querySelectorAll (n)}, Ao = função (n, t) {var e = n.matches || n [x (n , "matchesSelector")]; return (Ao = função (n, t) {return e.call (n, t)}) (n, t)}; "função" == typeof Sizzle && (Não = função (n, t) {return Sizzle (n, t) [0] || null}, Eo = Sizzle, Ao = Sizzle.matchesSelector), ao.selection = function () {return ao.select (fo.documentElement)}; var Co = ao.selection.prototype = []; Co.select = função (n) {var t, e, r, i, u = []; n = A (n); para (var o = -1, a = este.length; ++ o <a;) {u.push (t = []), t.parentNode = (r = este [o]). parentNode; para (var l = -1, c = r.length; ++ l <c;) (i = r [l])? (t.push (e = n.call (i, i .__ dados __, l, o)), e && "__ dados __" em i && (e .__ dados __ = i .__ dados __)): t.push (nulo)} retorno E (u)}, Co.selectAll = função (n) {var t, e, r = []; n = C (n), para (var i = -1, u = este.length; ++ i <u;) para (var o = isto [i], a = -1, l = o.length; + + a <l;) (e = o [a]) && (r.push (t = co (n.call (e, e .__ dados __, a, i))), t.parentNode = e); return E (r)}; var zo = "http://www.w3.org/1999/xhtml", Lo = {svg: "http://www.w3.org/2000/svg", xhtml: zo, xlink : "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/ 2000 / xmlns / "}; ao.ns = {prefixo: Lo, qualifica:function (n) {var t = n.indexOf (":"), e = n; return t> = 0 && "xmlns"! == (e = n.slice (0, t)) && (n = n. slice (t + 1)), Lo.hasOwnProperty (e)? {espa: Lo [e], local: n}: n}}, Co.attr = funo (n, t) {if (argumentos.length <2 ) {if ("string" == typeof n) {var e = this.node (); retorno n = ao.ns.qualify (n), n.local? e.getAttributeNS (n.space, n.local) : e.getAttribute (n)} para (t em n) this.each (z (t, n [t])); retorne isto} return this.each (z (n, t))}, Co.classed = função (n, t) {if (arguments.length <2) {if ("string" == typeof n) {var e = this.node (), r = (n = T (n)). comprimento, i = -1; if (t = e.classList) {para (; ++ i <r;) if (! T.contains (n ​​[i])) retorna! 1} else para (t = e.getAttribute (" class "); ++ i <r;) if (! q (n [i]). teste (t)) return! 1; return! 0} para (t em n) this.each (R (t, n [t])); return this} return this.each (R (n, t))}, co estilo = function (n, e, r) {var i = argumentos.length; if (3> i) { E se("string "! = typeof n) {2> i && (e =" "); para (rn) this.each (P (r, n [r], e)); devolva} se (2> i) {var u = this.node (); return t (u) .getComputedStyle (u, nulo) .getPropertyValue (n)} r = ""} retornar this.each (P (n, e, r))}, Co .property = function (n, t) {if (argumentos.length <2) {if ("string" == typeof n) retorna this.node () [n]; para (t in n) this.each (U (t, n [t])); return this} retorna this.each (U (n, t))}, Co.text = função (n) {return arguments.length? this.each ("função" == typeof n? function () {var t = n.apply (isto, argumentos); this.textContent = null == t? "": t}: null == n? function () {this.textContent = ""} : function () {this.textContent = n}): this.node (). textContent}, Co.html = função (n) {return argumentos.length? this.each ("função" == tipoof n? função ( ) {var t = n.apply (isto, argumentos); this.innerHTML = null == t? "": t}:null == n? function () {this.innerHTML = ""}: function () {this.innerHTML = n}): this.node (). innerHTML}, Co.append = função (n) {retorno n = j (n), this.select (function () {retornar this.appendChild (n.apply (this, arguments))})}, Co.insert = função (n, t) {return n = j (n), t = A (t), this.select (function () {retornar this.insertBefore (n.apply (this, argumentos), t.apply (this, argumentos) || null)})}, Co.remove = function () {return this.each (F)}, Co.data = função (n, t) {função e (n, e) {var r, i, u, o = n.length, s = e.length, h = Math.min (o, s), p = novo Matriz (s), g = novo Matriz (s), v = novo Matriz (o); if (t) {var d, y = novo c, m = novo Array (o), para (r = -1; ++ r <o;) (i = n [r]) && (y.has (d = t.call (i, i .__ dados __, r))? v [r] = i: y.set (d, i), m [r] = d), para (r = -1; ++ r <s;) (i = y.get (d = t.call) (e, u = e [r], r)))? i! ==! 0 && (p [r] = i, i .__ dados __ = u): g [r] = H (u), y.set ( d,! 0), para (r = -1; ++ r <o;) r em m && y.get (m [r])! ==! 0 &&(v [r] = n [r])} else {para (r = -1; ++ r <h;) i = n [r], u = e [r], i? (i .__ dados __ = u , p [r] = i): g [r] = H (u); para (; s> r; ++ r) g [r] = H (e [r]), para (; o> r; ++ r) v [r] = n [r]} g.update = p, g.parentNode = p.parentNode = v.parentNode = n.parentNode, a.push (g), l.push (p), f.push (v)} var r, i, u = -1, o = this.length, if (! argumentos.length) {para (n = new Array (o = (r = este [0]). length ); ++ u <o;) (i = r [u]) && (n [u] = i .__ dados __); retorno n} var a = Z ([]), l = E ([]), f = E ([]); if ("function" == typeof n) para (; ++ u <o;) e (r = este [u], n.call (r, r.parentNode .__ dados __, u) senão para (; ++ u <o;) e (r = isto [u], n); retorno l.enter = função () {retorno a}, l.exit = função () {retorno f}, l}, Co.datum = função (n) {return argumentos.length? this.property ("__ data __", n): this.property ("__ data __")}, co. filtro = função (n) {var t, e, r, i = []; "função"! = tipo de n && (n = O (n)); para (var u = 0, o = este.limento; o> u; u ++) {i.push (t = []), t.parentNode = (e = this [u]). parentNode; para (var a = 0, l = e.length; l> a; a ++) (r = e [a]) && n.call (r, r .__ data__, a, u) && t.push (r)} retornar E (i)}, co .ordem = function () {para (var n = -1, t = este.length; ++ n <t;) para (var e, r = isto [n], i = r.length-1, u = r [i] - i> = 0;) (e = r [i]) && (u && u! == e.nextSibling && u. parentNode.insertBefore (e, u), u = e); retorne isto}, Co.sort = function (n) {n = I.apply (isto, argumentos); para (var t = -1, e = this. length; ++ t <e;) this [t] .sort (n); return this.order ()}, .each = function (n) {returnY (isso, função (t, e, r) { n.call (t, t .__ dados __, e, r)})}, Co.call = função (n) {var t = co (argumentos); retorno n.apply (t [0] = isto, t), this}, Co.empty = function () {retorno! this.node ()}, Co.node = function () {para (var n = 0, t = este.length; t> n; n ++) para (var e = isto [n], r = 0, i = e.length; i> r; r ++) {var u = e [r]; se (u) retorna u} retorna nulo}, Co.size = function () {var n = 0; retornar Y (isso,function () {++ n}), n}; var qo = []; ao.selection.enter = Z, ao.selection.enter.prototype = qo, qo.append = Co.append, qo.empty = Co .empty, qo.node = Co.node, qo.call = Co.call, qo.size = Co.size, qo.select = função (n) {para (var t, e, r, i, u, o = [], a = -1, l = this.length; ++ a <l;) {r = (i = esta [a]). update, o.push (t = []), t.parentNode = i.parentNode; para (var c = -1, f = i.length; ++ c <f;) (u = i [c])? (t.push (r [c] = e = n.call ( i.parentNode, u .__ dados __, c, a)), e .__ dados __ = u .__ dados __): t.push (nulo)} retorno E (o)}, qo.insert = função (n, t) {argumentos de retorno .length <2 && (t = V (isto)), Co.insert.call (isto, n, t)}, ao.select = função (t) {var e; retorno "string" == typeof t? (e = [Não (t, fo)], e.parentNode = fo.documentElement) :( e = [t], e.parentNode = n (t)), E ([e])}, ao.selectAll = function ( n) {var t; return "string" == tipoof n? (t = co (Eo (n, fo)), t.parentNode = fo.documentElement): (t = co (n), t.parentNode = null ), E ([t])}, Co.on = função (n,t, e) {var r = argumentos.length; if (3> r) {if ("string"! = tipoof n) {2> r && (t =! 1); para (e em n) this.each ( X (e, n [e], t)); retorne isto} if (2> r) return (r = this.node () ["__ em" + n]) && r ._; e =! 1} retorne este .each (X (n, t, e))}; var Para = ao.map ({mouseenter: "mouseover", mouseleave: "mouseout"}); fo && To.forEach (função (n) {"on" + n in fo && To.remove (n)}); var Ro, Do = 0; ao.mouse = function (n) {retorno J (n, k ())}; var Po = this.navigator && / WebKit / .test .navigator.userAgent)? - 1: 0; ao.touch = função (n, t, e) {if (argumentos.length <3 && (e = t, t = k (). changedTouches), t) para (var r, i = 0, u = t.length; u> i; ++ i) if ((r = t [i]). identificador === e) retorno J (n, r)}, ao.behavior. drag = function () {função n () {this.on ("mousedown.drag", u) .on (função "touchstart.drag", o)} e (n, t, e, u,o) {função de retorno () {função a () {var n, e, r = t (h, v); r && (n = r [0] -M [0], e = r [1] -M [ 1], g | = n | e, M = r, p ({tipo: "arrastar", x: r [0] + c [0], y: r [1] + c [1], dx: n , dy: e}))} função l () {t (h, v) && (y.on (u + d, nulo). em (o + d, nulo), m (g), p ({tipo : "arrastar"})}} var c, f = isso, s = ao.event.target.correspondingElement || ao.event.target, h = f.parentNode, p = r.of (f, argumentos), g = 0, v = n (), d = ". Arrastar" + (nulo == v? "": "-" + v), y = ao.selecionar (e (s)) em (u + d, a). em (o + d, l), m = W (s), M = t (h, v); i? (c = i.apply (f, argumentos), c = [cx-M [0 ], cy-M [1]]): c = [0,0], p ({tipo: "dragstart"})}} var r = N (n, "arrastar", "arrastar", "arrastar") , i = null, u = e (b, ao.mouse, t, "mousemove", "mouseup"), o = e (G, ao.touch, m, "touchmove", "touchend"); retorno n. origem = função (t) {retorno arguments.length? (i = t, n): i}, ao.rebind (n, r, "on"}}, ao.touches = função (n, t) {return argumentos.length <2 && (t = k (). toques), t? co (t) .map (função (t) {var e = J (n , t); return e.identifier = t.identifier, e}): []}; var Uo = 1e-6, jo = Uo * Uo, Fo = Math.PI, Ho = 2 * Fo, Oo = Ho- Uo, Io = Fo / 2, Yo = Fo / 180, Zo = 180 / Fo, Vo = Math.SQRT2, Xo = 2, $ o = 4; ao.interpolateZoom = função (n, t) {var e, r , i = n [0], u = n [1], o = n [2], a = t [0], l = t [1], c = t [2], f = ai, s = lu , h = f * f + s * s; se (jo> h) r = Math.log (c / o) / vo, e = função (n) {retorno [i + n * f, u + n * s , o * Math.exp (Vo * n * r)]}; else {var p = Math.sqrt (h), g = (c * co * o + $ o * h) / (2 * o * Xo * p ), v = (c * co * o- $ o * h) / (2 * c * Xo * p), d = Math.log (Math.sqrt (g * g + 1) -g), y = Math .log (Math.sqrt (v * v + 1) -v); r = (yd) / Vo, e = função (n) {var t = n * r, e = rn (d), a = o / (Xo * p) * (e * un (Vo * t + d) -en (d)); retorno [i + a * f, u + a * s, o * e / rn (Vo * t + d) ]}} return e.duration = 1e3 * r, e}, ao.behavior.zoom = function () {função n (n) {n.on (L, s). em (Wo + ". zoom", p) .on ("dblclick.zoom", g) .on (R,h)} função e (n) {retorno [(n [0] -kx) / kk, (n [1] -ky) / kk]} função r (n) {retorno [n [0] * k.k + kx, n [1] * k.k + ky]} função i (n) {kk = Math.max (A [0], Math.min (A [1], n))} função u (n, t) {t = r (t), k.x + = n [0] -t [0], k.y + = n [1] -t [1]} funç˜ao o (t, e, r, o) { t .__ gráfico __ = {x: kx, y: k, k: kk}, i (Math.pow (2, o)), u (d = e, r), t = ao.select (t), C> 0 && (t = t.transition (). Duration (C)), t.call (n.event)} função a () {b && b.domain (x.range (). Map (função (n) {retorno (nk) .x) / kk}). map (x.invert)), w & w.domain (_. range (). map (função (n) {retorno (nk.y) / kk}). map (_. invert) )} função l (n) {z ++ || n ({tipo: "zoomstart"})} função c (n) {a (), n ({tipo: "zoom", escala: kk, traduzir: [kx, ky]})} função f (n) {- z || (n ({tipo: "zoomend"}), d = nulo)} função s () {função n () {a = 1, u (ao .mouse (i), h), c (o)} função r () {s.on (q, nulo) .on (T, nulo), p (a), f (o)} var i = isto, o = D.of (i, argumentos), a = 0, s = ao.selecione (t (i)) em (q, n). em (T, r), h = e (ao mouse (i)), p = W (i); Il.call (i), l ( o)} função h () {função n () {var n = ao.touches (g); retorno p = kk, n.forEach (função (n) {n.identifier em d && (d [n.identificador] = e (n))}), n} função t () {var t = ao.event.target; ao.select (t) .on (x, r) .on (b, a), _ push (t para (var e = ao.event.changedTouches, i = 0, u = e.length; u> i; ++ i) d [e [i] .identificador] = nulo; var l = n (), c = Date.now (); if (1 === l.length) {if (500> cM) {var = l [0]; o (g, f, d [f.identifier], Math.floor (Math.log (kk) /Mat.LN2) +1), S ()} M = c} mais if (l.length> 1) {var f = l [0], s = l [1], h = f [0] -s [0], p = f [1] -s [1]; y = h * h + p * p}} função r () {var n, t, e, r, o = ao.touches (g); Il.call (g); para (var a = 0, l = o.length; l> a; ++ a, r = null) se (e = o [a], r = d [e.identificador]) {se (t) quebra; n = e, t = r} se (r) {var = (f = e [0] -n [0]) * f + (f = e [ 1] -n [1]) * f, s = y & Math.sqrt (f / y); n = [(n [0] + e [0]) / 2, (n [1] + e [1]) / 2], t = [(t [0] + r [0]) / 2, (t [1] + r [1]) / 2],i (s * p)} M = nulo, u (n, t), c (v)} função a () {if (ao.event.touches.length) {para (var t = ao.event.changedTouches, e = 0, r = t.length, r> e; ++ e) exclua d [t [e] .identifier], para (var i in d) retorne void n ()} ao.selectAll (_). (m, null), w.on (L, s) .on (R, h), N (), f (v)} var p, g = isto, v = D. de (g, argumentos), d = {}, y = 0, m = ". zoom -" + ao.event.changedTouches [0] .identifier, x = "touchmove" + m, b = "touchend" + m, _ = [], w = ao.select (g), N = W (g); t (), l (v), w.on (L, nulo) .on (R, t)} função p () {var n = D.of (isto, argumentos); m? clearTimeout (m) :( Il.call (isto), v = e (d = y || ao.mouse (this)), l (n)), m = setTimeout (função ( ) {m = null, f (n)}, 50), S (), i (Math.pow (2, 0,002 * Bo ()) * kk), u (d, v), c (n)} função g () {var n = ao.mouse (isto), t = Math.log (kk) /Matemática.LN2;o (isto, n, e (n), ao.evento.shiftKey? Math.ceil (t ) -1: Math.floor (t) +1}} var v, d, y, m, M, x, b, _, w, k = {x: 0, y: 0, k: 1}, E = [960,500], A = Jo, C = 250, z = 0, L = "mousedown.zoom",q = "mousemove.zoom", T = "mouseup.zoom", R = "touchstart.zoom", D = N (n, "zoomstart", "zoom", "zoomend"); retorno Wo || (Wo = "onwheel" em fo? (Bo = função () {return-ao.event.deltaY * (ao.event.deltaMode? 120: 1)}, "roda"): "onmousewheel" em fo? (Bo = função ( ) {return ao.event.wheelDelta}, "mousewheel") :( Bo = função () {return-ao.event.detail}, "MozMousePixelScroll")), n.event = função (n) {n.each ( function () {var n = D (isto, argumentos), t = k; Hl? ao.select (this) .transition (). each ("start.zoom", function () {k = este .__ chart__ || {x: 0, y: 0, k: 1}, l (n)}). tween ("zoom: zoom", função () {var e = E [0], r = E [1], i = d ?d [0]: e / 2, u = d ?d [1]: r / 2, o = ao.interpolateZoom ([(ik.x) / kk, (uk.y) / kk, e /kk],[(it.x)/tk,(ut.y)/tk,e/tk]); função return (t) {var r = o (t), a = e / r [2]; este .__ gráfico __ = k = {x:ir [0] * a, y: ur [1] * a, k: a}, c (n)}}). each ("interrupt.zoom", function () {f (n)}). "end.zoom", function () {f (n)}) :( este .__ gráfico __ = k, l (n), c (n), f (n))})}, n.translate = função (t ) {return arguments.length? (k = {x: + t [0], y: + t [1], k: kk}, a (), n): [kx, ky]}, n.scale = function (t) {return argumentos.length? (k = {x: kx, y: ky, k: nulo}, i (+ t), a (), n): kk}, n.scaleExtent = função (t ) {return arguments.length? (A = null ==t? Jo: [+ t [0], + t [1]], n): A}, n.center = função (t) {return arguments.length (y = t && [+ t [0], + t [1]], n): y}, n.size = função (t) {return argumentos.length? (E = t && [+ t [0], + t [1]], n): E}, n.duração = função (t) {retorno arguments.length? (C = + t, n): C}, nx = função (t) {return arguments.length (b = t, x = t.copy (), k = {x: 0, y: 0, k: 1}, n): b}, ny = função (t) {retorno arguments.length? (w = t, _ = t.copy (), k = {x: 0, y: 0, k: 1}, n): w}, ao.rebind (n, D, "on")}; var Bo, Wo, Jo = [0,1 / 0];color = an, an.prototype.toString = function () {retornar this.rgb () + ""}, ao.hsl = ln; var Go = ln.prototype = novo um; Go.brighter = function (n) { return n = Math.pow (0,7, arguments.length? n: 1), novo ln (this.h, this.s, this.l / n)}, Go.darker = função (n) {return n = Math.pow (.7, arguments.length? N: 1), novo ln (this.h, this.s, n * this.l)}, Go.rgb = function () {retorno cn (this.h, this.s, this.l)}, ao.hcl = fn; var Ko = fn.prototype = new um; Ko.brighter = function (n) {return novo fn (this.h, this.c, Math.min (100, this.l + Qo * (arguments.length? N: 1)))}, Ko.darker = função (n) {return novo fn (this.h, this.c, Math.max (0, este .l-Qo * (arguments.length? n: 1)))}, Ko.rgb = function () {retornar sn (this.h, this.c, this.l) .rgb ()}, ao.lab = hn; var Qo = 18, nd = .95047, ta = 1, ea = 1,08883, ra = hn.prototype = novo an; ra.brighter = função (n) {retorno novo hn (Math.min (100, este .l + Qo * (arguments.length? n: 1)), this.a, this.b)}, ra.darker = função (n) {return new hn (Math.max (0, this.l-Qo * (arguments.length? n: 1)), this.a, this.b)}, ra.rgb = function ( ) {return pn (this.l, this.a, this.b)}, ao.rgb = mn; var ia = mn.prototype = new an; ia.brighter = function (n) {n = Math.pow ( .7, arguments.length? N: 1); var t = this.r, e = this.g, r = this.b, i = 30; retorno t || e || r? (T && i> t && (t = i), e & i> e && (e = i), r && i> r && (r = i), novo mn (Math.min (255, t / n), Math.min (255, e / n), Math.min (255, r / n))): novo mn (i, i, i)}, ia.darker = função (n) {retorno n = Math.pow (.7, arguments.length? N: 1), novo mn (n * this.r, n * this.g, n * this.b)}, ia.hsl = function () {retornar wn (this.r, this.g, this.b)}, ia.toString = function () {return "#" + bn (this.r) + bn (this.g) + bn (this.b)}; var ua = ao.map ({aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, água-marinha: 8388564, azul: 15794175, bege: 16119260, bisque: 16770244, preto: 0, branchedalmond:16772045, azul: 255, blueviolet: 9055202, castanho: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, carmesim: 14423100, ciano: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fúchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, ouro: 16766720, goldenrod: 14329120, cinza: 8421504, verde: 32768, greenyellow: 11403055,cinza: 8421504, melada: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, marfim: 16777200, cáqui: 15787660, lavanda: 15132410, lavandablush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, luzeslategray: 7833753, luzeslategrão: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linho: 16445670, magenta: 16711935, marrom: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, mocassim:16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, oliveira: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palmeira: 15657130, paladreen: 10025880, paleturquoise: 11529966, palietroletrado: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, rosa: 16761035, ameixa: 14524637, powderblue: 11591910, roxo: 8388736, rebeccapurple: 6697881, vermelho: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmão: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, prata: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, neve: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, azul-petróleo: 32896, cardo: 14204888, tomate: 16737095, turquesa: 4251856, violeta: 15631086, trigo: 16113331, branco: 16777215, fumo branco: 16119285, amarelo: 16776960, amarelo: 10145074}) ua.forCada ( função (n,t) {ua.set (n, Mn (t))}), ao.functor = En, ao.xhr = Um (m), ao.dsv = função (n, t) {função e (n, e, u) {argumentos.length <3 && (u = e, e = nulo); var o = Cn (n, t, nulo == e? r: i (e), u); retorno o.row = funç˜ao (n ) {return arguments.length? o.response (null == (e = n)? r: i (n)): e}, o} função r (n) {retorno e.parse (n.responseText)} i (n) {função de retorno (t) {retorno e.parse (t.responseText, n)}} função u (t) {retorno t.map (o) .join (n)} função o (n) {retorno a.test (n)? '"' + n.replace (/ \" / g, '""') + '"': n} var a = novo RegExp ('["' + n + "\ n]" ), l = n.charCodeAt (0); return e.parse = função (n, t) {var r; return e.parseRows (n, função (n, e) {if (r) retorno r (n, e -1); var i = new Função ("d", "retorno {" + n.map (função (n, t) {retorno JSON.stringify (n) + ": d [" + t + "]"}) .join (",") + "}"); r = t? função (n,e) {return t (i (n), e)}: i})}, e.parseRows = função (n, t) {função e () {if (f> = c) retorno o; se (i) return i =! 1, u; var t = f; if (34 === n.charCodeAt (t)) {para (var e = t; e ++ <c;) if (34 === n.charCodeAt (e )) {if (34! == n.charCodeAt (e + 1)) quebra; ++ e} f = e + 2; var r = n.charCodeAt (e + 1); retorno 13 === r? ( i =! 0,10 === n.charCodeAt (e + 2) && ++ f): 10 === r && (i =! 0), n.slice (t + 1, e) .replace (/ " "/ g, '"')} para (; c> f;) {var r = n.charCodeAt (f ++), a = 1; se (10 === r) i =! 0; else if (13 = == r) i =! 0,10 === n.charCodeAt (f) && (++ f, ++ a); else if (r! == l) continuar; retorno n.slice (t, fa) } return n.slice (t)} para (var r, i, u = {}, o = {}, a = [], c = n.length, f = 0, s = 0; (r = e ( ))! == o;) {para (var h = []; r! == u && r! == o;) h.push (r), r = e (); t && nulo == (h = t (h , s ++)) || a.push (h)} retorna a}, e.format = function (t) {if (Array.isArray (t [0])) retorna e.formatRows (t); var r = new y, i = []; return t.forEach (função (n) {para (var t em n) r.tem (t) || i.push (r.add (t))}), [i.map (o) .join (n)]. concat (t.map (função (t) {return i.map ( function (n) {return o (t [n])}). join (n)})). join ("\ n")}, e.formatRows = função (n) {return n.map (u). join ("\ n")}, e}, ao.csv = ao.dsv (",", "texto / csv"), ao.tsv = ao.dsv ("", "texto / valores separados por tabulação "); var oa, aa, la, ca, fa = isto [x (isto," requestAnimationFrame ")] || função (n) {setTimeout (n, 17)}; ao.timer = function () {qn. apply (this, arguments)}, ao.timer.flush = function () {Rn (), Dn ()}, ao.round = function (n, t) {retorno t? Math.round (n * (t = Math.pow (10, t))) / t: Math.round (n)}; var sa = ["y", "z", "a", "f", "p", "n", " \ xb5 "," m "," "," k "," M "," G "," T "," P "," E "," Z "," Y "]. map (Un); .formatPrefix = função (n, t) {var e = 0; retorno (n = + n) && (0> n && (n * = - 1), t && (n = ao.round (n, Pn (n, t) )), e = 1 + Math.floor (1e-12 + Math.log (n) / Math.LN10), e = Math.max (-24, Math.min (24,3 * Math.floor) -1) / 3)))), sa [8 + e / 3]} var ha = / (?: ([^ {])? ([<> = ^]))? ([+ \ -] )? ([$ #])? (0)? (\ D +)? (,)? (\ .-? D +)? ([Az%])? / I, pa = ao.map ({b: function (n) {return n.toString (2)}, c: funç˜ao (n) {return String.fromCharCode (n)}, o: funç˜ao (n) {return n.toString (8)}, x: funç˜ao ( n) {return n.toString (16)}, X: função (n) {retornar n.toString (16) .toUpperCase ()}, g: função (n, t) {retorno n.toPrecision (t)}, e: function (n, t) {retorno n.toExponencial (t)}, f: função (n, t) {retorno n.toFixed (t)}, r: função (n, t) {retorno (n = ao .round (n, Pn (n, t))) toFixed (Math.max (0, Math.min (20, Pn (n * (1 + 1e-15), t))))}}), ga = ao.time = {}, va = Data; Hn.prototype = {getDate: function () {retorna isso ._. getUTCDate ()}, getDay:function () {retorna isso ._. getUTCDay ()}, getFullYear: function () {retorna isso ._. getUTCFullYear ()}, getHours: function () {retorna isso ._. getUTCHours ()}, getMilliseconds: function ( ) {return this ._. getUTCMilliseconds ()}, getMinutes: function () {retorna isso ._. getUTCMinutes ()}, getMonth: function () {retorna isso ._. getUTCMonth ()}, getSeconds: function () { retorne isso ._. getUTCSeconds ()}, getTime: function () {retorne isso ._. getTime ()}, getTimezoneOffset: function () {retorne 0}, valueOf: function () {retorne isso ._. valueOf () }, setDate: function () {da.setUTCDate.apply (isto., argumentos)}, setDay: function () {da.setUTCDay.apply (isto., argumentos)}, setFullYear: function () {da. setUTCFullYear.apply (isto ._, argumentos)}, setHours: function () {da.setUTCHours.apply (isso., argumentos)}, setMilliseconds: function () {da.setUTCMilliseconds.apply (isto ._, argumentos) }, setMinutes: function () {da.setUTCMinutes.apply (this._,argumentos)}, setMonth: function () {da.setUTCMonth.apply (isto., argumentos)}, setSeconds: function () {da.setUTCSeconds.apply (isto., argumentos)}, setTime: function () { da.setTime.apply (this ._, arguments)}}; var da = Date.prototype; ga.year = On (função (n) {return n = ga.day (n), n.setMonth (0,1 ), n}, função (n, t) {n.setFullYear (n.getFullYear () + t)}, função (n) {return n.getFullYear ()}), ga.years = ga.ano.range, ga.years.utc = ga.year.utc.range, ga.day = On (função (n) {var t = new va (2e3,0); retorno t.setFullYear (n.getFullYear (), n.getMonth (), n.getDate ()), t}, função (n, t) {n.setDate (n.getDate () + t)}, função (n) {return n.getDate () - 1}), ga.days = ga.day.range, ga.days.utc = ga.day.utc.range, ga.dayOfYear = função (n) {var t = ga.ano (n); retorno Math.floor ((nt -6e4 * (n.getTimezoneOffset () - t.getTimezoneOffset ())) / 864e5)}, ["domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira "," sexta-feira "," sábado "]. forEach (função (n, t) {t = 7-t; var e = ga [n] = On (função (n) {return (n = ga.day ( n)). setDate (n.getDate () - (n.getDay () + t)% 7), n}, função (n, t) {n.setDate (n.getDate () + 7 * Math.floor (t)}}, function (n) {var e = ga.ano (n) .getDay (); return Math.floor ((ga.dayOfYear (n) + (e + t)% 7) / 7) - (e! == t)}); ga [n + "s"] = e.range, ga [n + "s"]. utc = e.utc.range, ga [n + "OfYear"] = funo (n) {var e = ga.ano (n) .getDay (); retorno Math.floor ((ga.dayOfYear (n) + (e + t)% 7) / 7)}}), ga.week = ga.sunday , ga.weeks = ga.sunday.range, ga.weeks.utc = ga.sunday.utc.range, ga.weekOfYear = ga.sundayOfYear; var ya = {"-": "", _: "", 0 : "0"}, ma = / ^ \ s * \ d + /, Ma = / ^% /; ao.locale = função (n) {return {numberFormat: jn (n), timeFormat: Yn (n)}} ; var xa = ao.locale ({decimal: ".", milhares: ",", agrupamento: [3], moeda: ["$", ""], dateTime: "% a% b% e% X% Y", data: "% m /% d /% Y", hora: "% H:% M:% S", pontos: [" AM "," PM "], dias: [" domingo "," segunda-feira "," terça-feira "," quarta-feira "," quinta-feira "," sexta-feira "," sábado "],
shortDays: ["Sun", "Seg", "Ter", "Qua", "Qui", "Sex", "Sábado"], meses: ["janeiro", "fevereiro", "março", "abril" , "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], shortMonths: ["Jan", "Feb", "Mar", " Apr "," May "," Jun "," Jul "," Aug "," Set "," Out "," Nov "," Dec "]}); ao.format = xa.numberFormat, ao.geo = {}, ft.prototype = {s: 0, t: 0, adicionar: função (n) {st (n, this.t, ba), st (ba.s, this.s, this), this.s this.t + = ba.t: this.s = ba.t}, reset: function () {this.s = this.t = 0}, valueOf: function () {return this.s}}; var ba = new ft; ao.geo.stream = função (n, t) {n && _ a.hasOwnProperty (n.tipo)? _a [n.type] (n, t): ht (n, t)}; var _a = {Característica: função (n, t) {ht (n.geometria, t)}, FeatureCollection: function ( n, t) {para (var e = n.features, r = -1, i = e.length; ++ r <i;) ht (e [r] .geometry, t)}}, wa = {Esfera : function (n, t) {t.sphere ()}, ponto: função (n, t) {n = n.coordinates, t.point (n [0], n [1], n [2])} , MultiPoint: function (n, t) {para (var e = n.coordinates, r = -1, i = e.length; ++ r <i;) n = e [r], t.point (n [i] 0], n [1], n [2])}, LineString: função (n, t) {pt (n.coordaços, t, 0)}, MultiLineString: function (n, t) {para (var e = n.ordinados, r = -1, i = e.length; ++ r <i;) pt (e [r], t, 0)}, Polígono: função (n, t) {gt (n.ordenados, t)}, MultiPolígonos: função (n, t) {para (var e = n.ordinadas, r = -1, i = e.length; ++ r <i;) gt (e [r], t)} , GeometryCollection: function (n, t) {para (var e = n.geometrias, r = -1, i = e.length; ++ r <i;) ht (e [r], t)}}; .geo.area = função (n) {retorno Sa = 0, ao.geo.stream (n, Na), Sa}; var Sa, ka = novo ft, Na = {esfera:function () {Sa + = 4 * Fo}, ponto: b, lineStart: b, linhaEnd: b, polygonStart: function () {ka.reset (), Na.lineStart = vt}, polygonEnd: function () {var n = 2 * ka; Sa + = 0> n? 4 * Fo + n: n, Na.line Inicia = Na.lineEnd = Na.ponto = b}}; ao.geo.bounds = funcao () {funcao n (n, t) {M.push (x = [f = n, h = n]), s> t && (s = t), t> p && (p = t)} função t (t, e) {var r = dt ([t * Yo, e * Yo]); se (y) {var i = mt (y, r), u = [i [1], - i [0], 0], o = mt (u, i); bt (o), o = _t (o); var l = tg, c = l> 0 1: -1, v = o [0] * Zo * c, d = xo (l)> 180 ; se (d ^ (v> c * g & c * t> v)) {var m = o [1] * Zo; m> p && (p = m)} mais se (v = (v + 360)% 360- 180, d ^ (v> c * g & c * t> v)) {var m = -o [1] * Zo; s> m && (s = m)} mais s> e && (s = e), e> p && (p = e); d (g) t (a, f, t)> a (f, h) e (h = t): a (t, h)> a (f, h) && (f = t ): h> = f? (f> t && (f = t), t> h && (h = t)): t> g? a (f, t)> a (f, h) && (h = t) : a (t, h)> a (f, h) &&(f = t)} senão n (t, e); y = r, g = t} função e () {b.point = t} função r () {x [0] = f, x [1] = h, b.ponto = n, y = nulo} função i (n, e) {se (y) {var r = ng; m + = xo (r)> 180? r + (r> 0? 360: -360) : v = n, d = e; Na.point (n, e), t (n, e)} função u () {Na.lineStart ()} função o () {i (v, d) , Na.lineEnd (), xo (m)> Uo && (f = - (h = 180)), x [0] = f, x [1] = h, y = nulo} função a (n, t) { return (t = n) <0? t + 360: t} função l (n, t) {retorno n [0] -t [0]} função c (n, t) {retorno t [0] <= t [1] t [0] <= n && n <= t [1]: n <t [0] || t [1] <n} var f, s, h, p, g, v, d, y , m, M, x, b = {ponto: n, lineStart: e, lineEnd: r, polygonStart: function () {b.point = i, b.lineStart = u, b.lineEnd = o, m = 0, Na.polygonStart ()}, polygonEnd: function () {Na.polygonEnd (), b.point = n, b.lineStart = e, b.lineEnd = r, 0> ka? (F = - (h = 180) , s = - (p = 90): m> Uo? p = 90: -Uo> m && (s = -90), x [0] = f, x [1] = h}}; função de retorno (n ) {p = h = - (f = s = 1/0), M = [], ao.geo.stream (n, b); var = M comprimento; se (t) {M.sort (l), para (var e, r = 1, i = M [0], u = [i]; t> r; ++ r) e = M [r], c (e [0], i ) || c (e [1], i)? (a (i [0], e [1])> a (i [0], i [1]) && (i [1] = e [1] ), a (e [0], i [1])> a (i [0], i [1]) && (i [0] = e [0])): u.push (i = e); para (var o, e, g = - (1/0), t = u.length-1, r = 0, i = u [t]; t> = r; i = e, ++ r) e = u [r], (o = a (i [1], e [0]))> g && (g = o, f = e [0], h = i [1])} retorno M = x = nulo, f === 1/0 || s === 1/0? [[NaN, NaN], [NaN, NaN]]: [[f, s], [h, p]]}} (), ao .geo.centroid = função (n) {Ea = Aa = Ca = za = La = qa = Ta = Ra = Da = Pa = Ua = 0, ao.geo.stream (n, ja); var = Da, e = Pa, r = Ua, i = t * t + e * e + r * r; retorno jo> i && (t = qa, e = Ta, r = Rã, Uo> Aa && (t = Ca, e = za , r = La), i = t * t + e * e + r * r, jo> i)? [NaN, NaN]: [Math.atan2 (e, t) * Zo, tn (r / Math.sqrt (i)) * Zo]} var Ea, Aa, Ca, za, La, qa, Ta, Ra, Da, Pa, Ua, ja = {esfera: b, ponto: St, linhaStart: Nt, linhaEnd: Et , polygonStart: function () {ja.lineStart = At}, polygonEnd: function () {ja.lineStart = Nt}}, Fa = Rt (zt, jt, Ht, [- Fo, -Fo / 2]), Ha = 1e9; ao.geo.clipExtent = function () {var n, t, e, r, i, u, o = {fluxo: função (n) {retorno i && (i.valid =! 1), i = u (n), i.valid =! 0, i}, extensão: function (a) {retorno arguments.length? (U = Zt (n = + a [0] [0], t = + a [0] [1], e = + a [1] [0], r = + a [1] [1]), i && (i.valid =! 1, i = null), o): [[n, t], [e, r]]} }; retorne o.extent ([[0,0], [960,500]])}, (ao.geo.conicEqualArea = function () {retornar Vt (Xt)}). raw = Xt, ao.geo.albers = function () {return ao.geo.conicEqualArea (). rotate ([96,0]) .centro ([- .6,38.7]) paralelos ([29,5,45,5]). escala (1070)}, ao. geo.albersUsa = function () {função n (n) {var u = n [0], o = n [1]; retorno t = nulo, e (u, o), t || (r (u, o) ), || i (u, o), t} var t, e, r, i, u = ao.geo.albers (), o = ao.geo.conicEqualArea (). rotate ([154,0 ] (.) paralelos ([55,65]), a = ao.geo.conicEqualArea (). rotate ([157,0]) .centro ([- 3,19.9]) .parallels ([8,18]), l = {ponto: função (n, e) {t = [n, e]}}; retorno n.invert = função (n) {var t = u.scale () , e = u.translate (),r = (n [0] -e [0]) / t, i = (n [1] -e [1]) / t; retorno (i> =. 12 &&. 234> i && r> = -. 425 && -. 214> r ?o: i> = .166 &&234> i && r> = -. 214 && - 115> r? A: u) .invert (n)}, n.stream = função (n) {var t = u .stream (n), e = o.stream (n), r = a.stream (n); return {ponto: função (n, i) {ponto (n, i), e. ponto (n, i), r.ponto (n, i)}, esfera: function () {t.sphere (), e.sphere (), r.sphere ()}, lineStart: function () {t.lineStart (), e.lineStart (), r.lineStart ()}, lineEnd: function () {t.lineEnd (), e.lineEnd (), r.lineEnd ()}, polygonStart: function () {t.polygonStart (), e.polygonStart (), r.polygonStart ()}, polygonEnd: function () {t.polygonEnd (), e.polygonEnd (), r.polygonEnd ()}}}, n.precision = function (t) {return arguments.length? (u.precisão (t), o.precisão (t), a.precisão (t), n): u.precisão ()}, n.escala = função (t) {return arguments.length? (escala (t), o.scale (0,35 * t), a.scale (t), n.translate (u.translate ())): u.scale ()}, n.translate = function (t) {if (! argumentos.length) retorna u.translate (); var c = u.scale (), f = + t [ 0], s = + t [1]; retorno e = u.translate (t) .clipExtent ([[f-.455 * c, s-.238 * c], [f + .455 * c, s + .238 * c]]) .fluxo (l) .ponto, r = o.translate ([f-.307 * c, s + .201 * c]). clipExtent ([[f-.425 * c + Uo, s +. 12 * c + Uo], [f-.214 * c-Uo, s + .234 * c-Uo]]). Stream (l). Ponto, i = a.translate ([f-.205 * c, s + .212 * c]). ClipExtent ([[f-.214 * c + Uo, s + .166 * c + Uo], [f-.115 * c-Uo, s + .234 * c-Uo]]). stream (l) .point, n}, n.scale (1070)}; var Oa, Ia, Ya, Za, Va, Xa, $ a = {ponto: b, lineStart: b, linhaEnd: b, polygonStart: function () {Ia = 0, $ a.lineStart = $ t}, polygonEnd: function () {$ a.lineStart = $ a.lineEnd = $ a.point = b, Oa + = xo (Ia / 2)}}, Ba = {ponto: Bt, lineStart: b, lineEnd: b, polygonStart: b, polígonEnd: b}, Wa = {ponto: Gt, lineStart: Kt, linhaEnd: Qt, polygonStart: function () {Wa.lineStart = ne }, polygonEnd: function () {Wa.point = Gt, Wa.lineStart = Kt, Wa.lineEnd = Qt}}; ao.geo.path = function () {função n (n) {return n && ("função" == typeof a && u.pointRadius (+ a.apply (isto, argumentos)), o && o.valid || (o = i (u)), ao.geo.stream (n, o)), u.result ()} função t () {retorno o = nulo, n} var e, r, i, u, o, a = 4.5; retorno n.area = function (n) {return Oa = 0, ao.geo.stream (n, i ($ a)), Oa}, n.centroide = função (n) {retorno Ca = za = La = qa = Ta = Ra = Da = Pa = Ua = 0, ao.geo.stream (n, i (Wa)), Ua [Da / Ua, Pa / Ua]: Ra? [Qa / Ra, Ta / Ra]: La? [Ca /La,za/La]:[NaN ,NaN]},n.bounds=function(n){return Va = Xa = - (Ya = Za = 1/0), ao.geo.stream (n, i ( Ba)), [[Ya, Za], [Va, Xa]]}, n.projeção = função (n) {return argumentos.length? (I = (e = n)? N.stream || re (n) ): m, t ()): e}, n.context = função (n) {return argumentos.length? (u = null == (r = n)? novo Wt: novo te (n), "função" ! = typeof a && u.pointRadius (a), t ()): r}, n.pointRadius = função (t) {return arguments.length? (a = "função" == tipo de t? t: (u.pointRadius (+ t), + t), n): a}, n.projection (ao.geo.albersUsa ()). contexto (null)}, ao.geo.transform = função (n) {return {stream: função (t) {var e = new ie (t); para (var r in n) e [r] = n [r]; return e}}}, ie.prototype = {ponto: função (n, t) {this.stream.point (n, t)}, esfera: function () {this.stream.sphere ()}, lineStart: function () {this.stream.lineStart ()}, lineEnd: function () {isto .stream.lineEnd ()}, polygonStart: function () {this.stream.polygonStart ()}, polygonEnd: function () {this.stream.polygonEnd ()}}, ao.geo.projection = oe, ao.geo .projectionMutator = ae, (ao.geo.equirectangular = function () {return oe (ce)}) raw = ce.invert = ce, ao.geo.rotation = função (n) {função t (t) {retorno t = n (t [0] * Yo, t [1] * Yo), t [0] * = Zo, t [1] * = Zo, t} retorno n = se (n [0]% 360 * Yo , n [1] * Yo, n.length> 2? n [2] * Yo: 0), t.invert = funo (t) {retorno t = n.invert (t [0] * Yo, t [1 ] * Yo), t [0] * = Zo, t [1] * = Zo, t}, t}, fe.invert = ce, ao.geo.circle = function () {função n () {var n = "função" == tipoof r? r.apply (isto, argumentos): r, t = se (-n [0] * Yo, -n [1] * Yo, 0) .invert, i = []; return e (nulo, nulo, 1, {ponto: função (n, e) {i.push (n = t (n, e)), n [0] * = Zo, n [1] * = Zo}}), {tipo: "Polígono", coordenadas: [i]}} var t, e, r = [0,0], i = 6; retorno n.origin = função (t) {retorno arguments.length? (r = t, n): r}, n.angle = função (r) {retorno arguments.length? (e = ve ((t = + r) * Yo, i * Yo), n): t}, n.precisão = função (r) {retorno arguments.length? (e = ve (t * Yo, (i = + r) * Yo), n): i}, n.angle (90)}, ao.geo.distance = função (n, t) {var e, r = (t [0] -n [0]) * Yo, i = n [1] * Yo, u = t [1] * Yo, o = Math.sin (r), a = Math.cos (r), l = Math.sin (i), c = Math.cos (i), f = Math.sin ( u), s = Math.cos (u); retorno Math.atan2 (Math.sqrt ((e = s * o) * e + (e = c * fl * s * a) * e), l * f + c * s * a)}, ao.geo.graticule = function () {função n () {return {type: "MultiLineString", coordenadas: t ()}} função t () {return ao.range (Math.ceil (u / d) * d, i, d). mapa (h) .concat (ao.range (Math.ceil (c / y) * y, l, y). mapa (p)). concat (ao . (Math.ceil (r / g) * g, e, g) .filter (função (n) {retorno xo (n% d)> Uo}). map (f)). concat (ao.range ( Math.ceil (a / v) * v, o, v) .filter (função (n) {retorno xo (n% y)> Uo}). Map (s)}} var e, r, i, u, o, a, l, c, f, s, h, p, g = 10, v = g, d = 90, y = 360, m = 2.5; retorno n.lines = function () {return t (). map (function (n) {return {type: "LineString", coordenadas: n}})}, n.outline = function () {return {tipo: "Polygon", coordenadas: [h (u) .concat (p (l) .segmento (1), h (i) .reverse (). slice (1), p (c) .reverse (). slice (1)}]}}, n.extent = function (t) { return arguments.length? n.majorExtent (t) .minorExtent (t): n.minorExtent ()}, n.majorExtent = função (t) {return arguments.length? (u = + t [0] [0], i = + t [1] [0], c = + t [0] [1], l = + t [1] [1], u> i && (t = u, u = i, i = t), c> l && (t = c, c = l, l = t), n.precisão (m)): [[u, c], [i, l]]}, n.minorExtent = função (t) {retornar argumentos.length? (r = + t [0] [0], e = + t [1] [0], a = + t [0] [1], o = + t [1] [1], r> e && (t = r, r = e, e = t), a> o && (t = a, a = o, o = t), n.precisão (m)): [ [r, a], [e, o]]}, n.step = função (t) {return arguments.length? n.majorStep (t) .minorStep (t): n.minorStep ()}, n.majorStep = function (t) {return argumentos.length? (d = + t [0], y = + t [1], n): [d, y]}, n.minorStep = função (t) {argumentos de retorno. comprimento? (g = + t [0], v = + t [1], n): [g, v]}, n.precisão = função (t) {retorno arguments.length? (m = + t, f = ye (a, o, 90), s = me (r, e, m), h = ye (c, l, 90), p = m (u, i, m), n): m}, n .majorExtent ([[- 180, -90 + Uo], [180,90-Uo]]). minorExtent ([[- 180, -80-Uo], [180,80 + Uo]]), ao. geo.greatArc = function () {função n () {return {tipo: "LineString", coordenadas: [t || r.apply (isto, argumentos), e || i.apply (this, arguments)]}} var t, e, r = Eu, i = xe; retorno n.distance = função () {return ao.geo.distance (t || r.apply (isto, argumentos),e || i.apply (this, arguments)}}, n.source = function (e) {return argumentos.length? (r = e, t = "função" == tipoof e? null: e, n): r}, n.target = função (t) {retorno arguments.length? (i = t, e = "função" == tipoof t? nulo: t, n): i}, n.precisão = function () { return arguments.length? n: 0}, n}, ao.geo.interpolate = function (n, t) {retorno ser (n [0] * Yo, n [1] * Yo, t [0] * Yo, t [1] * Yo)}, ao.geo.length = função (n) {retorno Ja = 0, ao.geo.stream (n, Ga), Ja}; var Ja, Ga = {esfera: b, ponto : b, lineStart: _e, lineEnd: b, polígonoStart: b, polígonoEnd: b}, Ka = nós (função (n) {retornar Math.sqrt (2 / (1 + n))}, função (n) {retorno 2 * Math.asin (n / 2)}); (ao.geo.azimuthalEqualArea = função () {retorno oe (Ka)}). Raw = Ka; var Qa = nós (função (n) {var t = Math .acos (n); retorno t && t / Math.sin (t)}, m); (ao.geo.azimuthalEquidistant = function () {retorno oe (Qa)}). raw = Qa, (ao.geo.conicConformal = function () {retorno Vt (Se)}). raw = Se, (ao.geo.conicEquidistant = function () {retorno Vt (ke)}). raw = ke; var nl = nós (função (n) {retorno 1 / n}, Math.atan); (ao.geo.gnomonic = function () { return oe (nl)}). raw = nl, Ne.invert = função (n, t) {retorno [n, 2 * Math.atan (Math.exp (t)) - Io]}, (ao.geo. mercator = function () {return Ee (Ne)}). raw = Ne; var (tl = nós (function () {return 1}, Math.asin); (ao.geo.orthographic = function () {retorno oe ( tl)}). raw = var el = nós (função (n) {retorno 1 / (1 + n)}, função (n) {retorno 2 * Math.atan (n)}); .stereographic = função () {retorno oe (el)}). raw = el, Ae.invert = função (n, t) {retorno [-t, 2 * Math.atan (Math.exp (n)) - Io ]}, (ao.geo.transverseMercator = function () {var n = Ee (Ae), t = n.center, e = n.rotate; return n.center = funç˜ao (n) {return n? t ([ -n [1], n [0]]): (n = t (), [n [1], - n [0]])}, n.rotate = função (n) {retornar n? e ([ n [0], n [1], n.length> 2? n [2] +90: 90]) :( n = e (), [n [0], n [1], n [2] - 90])}, e ([0,0,90])}). Raw = Ae, ao.geom = {}, ao.geom.hull = função (n) {função t (n) {if (n.length <3) return []; var t, i = En (e), u = En (r), o = n.length, a = [], l = []; para (t = 0; o> t; t ++) a.push ([+ i.call (isto, n [t], t), + u.call (isto, n [t ], t), t]), para (a.sort (qe), t = 0; o> t; t ++) l.push ([a [t] [0], - a [t] [1]] ); var c = Le (a), f = Le (l), s = f [0] === c [0], h = f [f.length-1] === c [c.length- 1], p = []; para (t = c.length-1; t> = 0; - t) p.push (n [a [c [t]] [2]]); + s; t <f.length-h; ++ t) p.push (n [a [f [t]] [2]]); retorno p} var e = Ce, r = ze; retorno arguments.length t (n) :( tx = função (n) {return argumentos.length? (e = n, t): e}, ty = função (n) {return argumentos.length? (r = n, t): r}, t)}, ao.geom.polygon = função (n) {retorno ko (n, rl), n}; var rl = ao.geom.polygon.prototype = []; rl.area = function () {para (var n, t = -1, e = este.length, r = isto [e-1], i = 0; ++ t <e;) n = r, r = isto [t], i + = n [1] * r [0] -n [0] * r [1]; return.5 * i}, rl.centroid = função (n) {var t, e, r = -1, i = isto. comprimento, u = 0, o = 0, a = isto [i-1], para (argumentos.comprimento || (n = -1 / (6 * this.area ())); ++ r <i;) t = a, a = isto [r], e = t [0] * a [1] - a [0] * t [1], u + = (t [0] + a [0]) * e, o + = (t [1] + a [1]) * e; retorno [u * n, o * n]}, rl.clip = function (n) {para (var t, e, r, i, u, o, a = De (n), l = -1, c = este.Comprimento-De (este) , f = isto [c-1]; ++ l <c;) {para (t = n.slice (), n.length = 0, i = isto [l], u = t [(r = t. comprimento-a) -1], e = -1; ++ e <r;) o = t [e], Te (o, f, i) (Te (u, f, i) || n.push (Re (u, o, f, i)), n.push (o)): Te (u, f, i) & n.push (Re (u, o, f, i)), u = o; a && n .push (n [0]), f = i} return n}; var il, ul, ol, ai, ll, cl = [], fl = []; Ye.prototype.prepare = function () {para ( var n, t = this.edges, e = t.length; e -;) n = t [e] .edge, nb && n.a || t.splice (e, 1); return t.sort (Ve) t.length}, tr.prototype = {start: function () {retornar this.edge.l === this.site?this.edge.a:this.edge.b},end:function(){retorno this.edge.l === this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e, r, i; if (n ) {if (tP = n, tN = nN, nN && (n.NP = t), nN = t, nR) {para (n = nR; nL;) n = nL; nL = t} senão nR = t; e = n} senão este ._? (N = ou (isto. _), tP = nulo, tN = n, nP = nL = t, e = n): (tP = tN = nulo, isto ._ = t, e = nulo); para (tL = tR = nulo, tU = e, tC =! 0, n = t; e & eC;) r = eU, e === rL? (i = rR, i && i.C? (eC = iC =! 1, rC =! 0, n = r): (n === eR && (ir (isto, e), n = e, e = nU), eC =! 1, rC =! 0, ur (isto, r))) :( i = rL, i && i.C? (eC = iC =! 1, rC =! 0, n = r) :( n === eL && (ur (isto, e), n = e, e = nU), eC =! 1, rC =! 0, ir (isto, r))), e = nU; isto ._. C =! 1}, remove: função (n) {nN && (nNP = nP), nP && (nPN = nN), nN = nP = nulo; var t, e, r, i = nU, u = nL, o = nR; se (e = u? o? ou (o): u: o, i? iL === n? iL = e: iR = e: isto. = =, e & = (e = =, E = =, =, e = =, e = e = = o , iL = n, eR = o, oU = e): (eU = i, i = e, n = eR)): (r = nC, n = e), n && (nU = i), r) { if (n && n.C) retorna void (nC =! 1); do {if (n === this ._) quebra; if (n === iL) {se (t = iR, tC && (tC =!1, iC =! 0, ir (isto, i), t = iR), tL && t.LC || tR && t.RC) {tR && t.RC || (tLC =! 1, tC =! 0, ur (isto, t ), t = iR), tC = iC, iC = tRC =! 1, ir (isto, i), n = isto ._; quebra}} mais se (t = iL, tC && (tC =! 1, iC = ! 0, ur (isto, i), t = iL), tL && t.LC || tR && t.RC) {tL && t.LC || (tRC =! 1, tC =! 0, ir (isto, t), t = iL), tC = iC, iC = tLC =! 1, ur (isto, i), n = isto ._; quebra} tC =! 0, n = i, i = iU} enquanto (! nC); n && ( nC =! 1)}}}, ao.geom.voronoi = função (n) {função t (n) {var t = nova Matriz (n.length), r = a [0] [0], i = a [0] [1], u = a [1] [0], o = a [1] [1]; retorno ar (e (n), a) .células.forCada (função (e, a) {var l = e.edges, c = e.site, f = t [a] = comprimento_l.l.map (função (n) {var t = n.start (); retorno [tx, ty]}): cx> = r && c.x <= u && c.y> = i && c.y <= o? [[r, o], [u, o], [u, i], [r, i]]: []; .point = n [a]}), t} função e (n) {retorno n.map (função (n, t) {retorno {x: Math.round (u (n, t) / Uo) * Uo, y:Math.round (o (n, t) / Uo) * Uo, i: t}})} var = Ce, i = ze, u = r, o = i, a = sl; retorno n? T (n ): (t.links = function (n) {return ar (e (n)). edges.filter (função (n) {retorno nl && n.r}). map (função (t) {retorno {fonte: n [ tli], alvo: n [tri]}}}}, t.triangles = função (n) {var t = []; retorno ar (e (n)). cells.forEach (função (e, r) {para (var i, u, o = e.site, a = e.edges.sort (Ve), l = -1, c = comprimento a, f = a [c-1] .edge, s = fl == = o? fr: fl; ++ l <c;) i = f, u = s, f = a [l] .edge, s = fl === o? fr: fl, r <ui && r <si && cr (o , u, s) <0 && t.push ([n [r], n [ui], n [si]])}), t}, tx = função (n) {return argumentos.length? (u = En ( r = n), t): r}, ty = função (n) {return argumentos.length? (o = En (i = n), t): i}, t.clipExtent = função (n) {argumentos de retorno (a = null == n? sl: n, t): a === sl? null: a}, t.size = função (n) {return argumentos.length? t.clipExtent (n && [[ ]]] 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0: a var var var var var var var var var var var var var var var var var var var1e6]]; ao.geom.delaunay = função (n) {return ao.geom.voronoi (). Triângulos (n)}, ao.geom.quadtree = função (n, t, e, r, i) {função u (n) {função u (n, t, e, r, i, u, o, a) {se (! éNaN (e) &&! éNaN (r)) se (n.leaf) {var l = nx , f = ny; if (nulo! = l) se (xo (le) + xo (fr) <. 01) c (n, t, e, r, i, u, o, a); = n.point; nx = ny = n.ponto = nulo, c (n, s, l, f, i, u, o, a), c (n, t, e, r, i, u, o, a)} senão nx = e, ny = r, n.ponto = t} senão c (n, t, e, r, i, u, o, a)} função c (n, t, e, r, i , o, a, l) {var c = .5 * (i + a), f = .5 * (o + l), s = e> = c, h = r> = f, p = h << 1 | s; n.leaf =! 1, n = n.nodes [p] || (n.nodes [p] = hr ()), s? I = c: a = c, h? O = f: l = f, u (n, t, e, r, i, o, a, l)} var f, s, h, p, g, v, d, y, m, m = en (a), x = En (l); se (nulo! = T) v = t, d = e, y = r, m = i; sen se (y = m = - (v = d = 1/0), s = [ ], h = [], g = n.length, o) para (p = 0; g> p; ++ p) f = n [p], fx <v && (v = fx), fy <d && (d = fy), fx> y && (y = fx), fy> m && (m = fy), s.push (fx), h.push (fy), senão para (p = 0; g> p;++ p) {var b = + M (f = n [p], p), _ = + x (f, p) v> b && (v = b), d> _ && (d = _), b > y && (y = b), _> m && (m = _), s.push (b), h.push (_)} var w = yv, S = md; w> S? m = d + w: y = v + S; var k = hr (); if (k.add = função (n) {u (k, n, + M (n, ++ p), + x (n, p), v, d, y, m)}, k.visit = função (n) {pr (n, k, v, d, y, m)}, k.find = função (n) {retorno gr (k, n [0 ], n [1], v, d, y, m)}, p = -1, nulo == t) {para (; ++ p <g;) u (k, n [p], s [p ], h [p], v, d, y, m); - p) mais n.forEach (k.add); retorno s = h = n = f = nulo, k} var o, a = Ce, l = ze; retorno (o = argumentos.length)? (a = fr, l = sr, 3 === o && (i = e, r = t, e = t = 0), u (n)) :( ux = function (n) {return argumentos.length? (a = n, u): a}, uy = função (n) {return argumentos.length? (l = n, u): l}, u.extent = function (n) {return argumentos.length? (null == n? t = e = r = i = null: (t = + n [0] [0], e = + n [0] [1], r = + n [1] [0], i = + n [1] [1]), u): null == t? null: [[t, e], [r, i]]}, dimensão do u = function (n) {return argumentos.length? (null == n? t = e = r = i = null: (t = e = 0, r = + n [0],i = + n [1]), u): null == t? null: [rt, ie]}, u)}, ao.interpolateRgb = vr, ao.interpolateObject = dr, ao.interpolateNumber = yr, ao. interpolateString = mr; var hl = / [- +]? (?: \ d + \.? d \ | \.? d +) (?: [eE] [- +]? \ d +)? / g, pl = new RegExp (hl.source, "g"); ao.interpolate = Mr, ao.interpolators = [function (n, t) {var e = typeof t; return ("string" === e? ua.has (t.toLowerCase ()) || / ^ (# | rgb \ (| hsl \ () / i.test (t)? vr: mr: t instanceof um? vr: Array.isArray (t)? xr: " objeto "=== e && isNaN (t)? dr: yr) (n, t)}], ao.interpolateArray = xr; var gl = function () {retorno m}, vl = ao.map ({linear: gl, poly: Er, quad: função () {retorno Sr}, cubic: function () {retorno kr}, sin: function () {retorno Ar}, exp: function () {retorno Cr}, circle: function () { return zr}, elástico: Lr, anterior: qr, salto: function () {retorno Tr}}), dl = ao.map ({"in": m, out: ", in-out": wr, " out-in ": função (n) {retorno wr (_r (n))}};ease = function (n) {var = n.indexOf ("-"), e = t> = 0? n.slice (0, t): n, r = t> = 0? n.slice (t + 1): "in"; return e = vl.get (e) || gl, r = dl.get (r) || m, br (r (e.apply (nulo, lo.call (argumentos, 1) )))}, ao.interpolateHcl = Rr, ao.interpolateHsl = Dr, ao.interpolateLab = Pr, ao.interpolateRound = Ur, ao.transform = função (n) {var t = fo.createElementNS (ao.ns.prefix .svg, "g"); return (ao.transform = função (n) {if (null! = n) {t.setAttribute ("transformar", n); var e = t.transform.baseVal.consolidate () } return new jr (e? e.matrix: yl)}) (n)}, jr.prototype.toString = function () {retorno "translate (" + this.translate + ") rotate (" + this.rotate + ") skewX ("+ this.skew +") scale ("+ this.scale +") "}; var yl = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0}; ao.interpolateTransform = $ r, ao.layout = {}, ao.layout.bundle = function () {função return (n) {para (var t = [], e = -1, r = n.length;++ e <r;) t.push (Jr (n [e])); return t}}, ao.layout.chord = function () {função n () {var n, c, s, h, p , g = {}, v = [], d = ao.range (u), y = [], para (e = [], r = [], n = 0, h = -1; ++ h < u;) {para (c = 0, p = -1; ++ p <u;) c + = i [h] [p]; v.push (c), y.push (ao.range (u)) , n + = c} para (o && d.sort (função (n, t) {retorno o (v [n], v [t])}), a && y.forEach (função (n, t) {n.sort (função (n, e) {return a (i [t] [n], i [t] [e])})}), n = (Ho-f * u) / n, c = 0, h = -1 ; ++ h <u;) {para (s = c, p = -1; ++ p <u;) {var m = d [h], M = y [m] [p], x = i [ m] [M], b = c, _ = c + = x * n; g [m + "-" + M] = {índice: m, subíndice: M, startAngle: b, endAngle: _, value: x}} r [m] = {index: m, startAngle: s, endAngle: c, valor: v [m]}, c + = f} para (h = -1; ++ h <u;) para (p = h- 1; ++ p <u;) {var w = g [h + "-" + p], S = g [p + "-" + h]; (w.value || S.value) && e.push (w .value <S.value? {fonte: S, alvo: w}: {fonte: w, destino: S}}} l && t ()} função t () {e.sort (função (n, t) {retorno l ((n.source.value + n.target.value) / 2, (t.source.value + t.target.value) / 2)})} var e, r, i, u, o, a, l, c = {}, f = 0; return c.matrix = função (n) {return argumentos.length? (u = (i = n) && i.length, e = r = null, c): i}, c.padding = função (n) {argumentos de retorno Comprimento? (f = n, e = r = nulo, c): f}, c.sortGroups = função (n) {retorno arguments.length? (o = n, e = r = null, c): o} , c.sortSubgroups = function (n) {return argumentos.length? (a = n, e = null, c): a}, c.sortChords = função (n) {return argumentos.length? (l = n, e & t (), c): l}, c.chords = function () {return e || n (), e}, c.groups = function () {retorno r || n (), r}, c}, ao.layout.force = function () {função n (n) {função return (t, e, r, i) {se (t.point! == n) {var u = t.cx-nx, o = t.cy-ny, a = ie, l = u * u + o * o; if (l> a * a / y) {if (v> l) {var = t.charge / l; n.px - = u * c, n.py- = o * c} retornar! 0} if (t.point && l && v> l) {var = t.pointCharge / l; n.px- = u * c, n.py- = o * c}} return! t.charge}} função t (n) {n.px = ao.event.x, n.py = ao.event.y, l.resume ()} var e, r, i, u, o, a, l = {}, c = ao.dispatch ("start", "tick", "end") , f = [1,1], s = 0,9, h = ml, p = Ml, g = -30, v = xl, d = 0,1, y = 0,64, M = [], x = [] return l.tick = function () {if ((i * =. 99) <. 005) return e = null, c.end ({tipo: "fim", alfa: i = 0}), 0; var t, r, l, h, p, v, y, m, b, _ = Comprimento, w = x.length, para (r = 0; w> r; ++ r) l = x [r ], h = l.source, p = l.alvo, m = px-hx, b = py-hy, (v = m * m + b * b) && (v = i * o [r] * (( v = Math.sqrt (v)) - u [r]) / v, m * = v, b * = v, px- = m * (y = h.peso + p.peso? h.peso / (h peso + peso leve): 5), py = b * y, h + x = m * (y = 1-y), h + y = b * y), se ((y = i * d) ) && (m = f [0] / 2, b = f [1] / 2, r = -1, y)) para (; ++ r <_;) l = M [r], l.x + = (ml.x) * y, l.y + = (bl.y) * y; se (g) para (ri (t = ao.geom.quadtree (M), i, a), r = -1; + + r <_;) (l = M [r]). fixo || t.visit (n (l)); para (r = -1; ++ r <_;) l = M [r], l .fixed? (lx = l.px, ly = l.py): (lx - = (l.px- (l.px = lx)) * s, ly - = (l.py- (l.py = ly)) * s); c.tick ({tipo: "tick ", alpha: i})}, l.nodes = função (n) {return arguments.length? (M = n, l): M}, l.links = função (n) {return arguments.length? ( x = n, l): x}, l.size = função (n) {retorno arguments.length? (f = n, l): f}, l.linkDistance = função (n) {return arguments.length? ( h = "function" == typeof n? n: + n, l): h}, l.distance = l.linkDistance, l.linkStrength = função (n) {return argumentos.length? (p = "função" = = typeof n? n: + n, l): p}, l.friction = função (n) {return argumentos.length? (s = + n, l): s}, l.charge = função (n) { return arguments.length? (g = "função" == tipoof n? n: + n, l): g}, l.chargeDistance = função (n) {return argumentos.length? (v = n * n, l) : Math.sqrt (v)}, l.gravity = função (n) {retorno arguments.length? (D = + n, l): d}, l.theta = função (n) {return arguments.length? ( y = n * n, l): Math.sqrt (y)}, l.alpha = função (n) {retorno arguments.length? (n = + n, i? n> 0? i = n: (ec = null, et = NaN, e = nulo, c.end ({tipo:"fim", alfa: i = 0})): n> 0 && (c.start ({tipo: "início", alfa: i = n}), e = qn (l.tick)), l): i }, l.start = function () {função n (n, r) {if (! e) {para (e = nova matriz (i), l = 0; i> l; ++ l) e [l] = []; para (l = 0; c> l; ++ l) {var u = x [l]; e [u.source.index] .push (u.target), e [u.target.index ] .push (u.source)}} para (var o, a = e [t], l = -1, f = a.length; ++ l <f;) if (! isNaN (o = a [l ] [n])) return o return Math.random () * r} var t, e, r, i = Comprimento, c = x.length, s = f [0], v = f [1] para (t = 0; i> t; ++ t) (r = M [t]). índice = t, r.peso = 0; para (t = 0; c> t; ++ t) r = x [t], "número" == typeof r.source && (r.source = M [r.source]), "número" == tipoof r.target && (r.target = M [r.target]), + + r.source.weight, ++ r.target.weight; para (t = 0; i> t; ++ t) r = M [t], éNaN (rx) && (rx = n ("x", s)), isNaN (ry) && (ry = n ("y", v)), isNaN (r.px) && (r.px = rx), isNaN (r.py) && (r.py = ry );if (u = [], "função" == typeof h) para (t = 0; c> t; ++ t) u [t] = + h.call (isto, x [t], t); para (t = 0; c> t; ++ t) u [t] = h; se (o = [], "função" == tipoof p) para (t = 0; c> t; ++ t) o [t] = + p.call (isso, x [t], t); else para (t = 0; c> t; ++ t) o [t] = p; if (a = [], " função "== typeof g) para (t = 0; i> t; ++ t) a [t] = + g.call (isto, M [t], t); else para (t = 0; i> t; ++ t) a [t] = g; retorno l.resume ()}, l.resume = function () {retorno l.alpha (.1)}, l.stop = function () {retorno l. alpha (0)}, l.drag = function () {return r || (r = ao.behavior.drag (). origem (m) .on ("dragstart.force", Qr) .on ("arrastar. force ", t) .on (" dragend.force ", ni)), argumentos.length? void this.on (" mouseover.force ", ti) .on (" mouseout.force ", ei) .call (r ): r}, ao.rebind (l, c, "on")}; var ml = 20, Ml = 1, xl = 1/0; ao.layout.hierarchy = function () {função n (i) { var u, o = [i], a = []; para (i.depth = 0; null! = (u = o.pop ());) if (a.push (u), (c = e.call (n, u, u.depth)) && (l = c.length)) {para (var l, c, f; - l> = 0;) o. push (f = c [l]), f.parent = u, f.depth = u.depth + 1; r && (u.value = 0), u.children = c} mais r && (u.value = + r .call (n, u, u.depth) || 0), delete u.children; retorno oi (i, função (n) {var e, i; t && (e = n.children) && e.sort (t) , r && (i = n.parent) && (i.value + = n.value)}), a} var = ci, e = ai, r = li; return n.sort = function (e) {argumentos de retorno. length? (t = e, n): t}, n.children = função (t) {return argumentos.length? (e = t, n): e}, n.value = função (t) {argumentos de retorno. length? (r = t, n): r}, n.revalue = função (t) {return r && (ui (t, função (n) {n.children && (n.value = 0)}), oi (t , função (t) {var e; t.children || (t.value = + r.call (n, t, t.depth) || 0), (e = t.parent) && (e.value + = t.value)})), t}, n}, ao.layout.partition = function () {função n (t, e, r, i) {var u = t.children; if (tx = e, ty) = t.depth * i, t.dx = r, t.dy = i, u && (o = u.length)) {var o, a, l, c = -1; para (r = t.value? r / t.value: 0; ++ c <o;) n (a = u [c], e, l = a.value * r, i), e + = l}} função t (n) {var e = n.crianças, r = 0; se (e && (i = e.length)) para (var i, u = -1; ++ u <i;) r = Math.max (r, t (e [u])); retorno 1 + r} função e (e, u) {var = r.call (isto, e, u); retorne n (o [0], 0, i [0], i [1] / t (o [0])), o} var r = ao.layout.hierarchy (), i = [1,1]; return e.size = função (n) {retorno arguments.length? (i = n, e): i}, ii (e , r)}, ao.layout.pie = function () {função n (o) {var a, l = o.length, c = o.map (função (e, r) {retorno + t.call (n , e, r)}), f = + ("função" == tipoof r? r.apply (isto, argumentos): r), s = ("função" == tipoof i? i.apply (isto, argumentos ): i) -f, h = Math.min (Math.abs (s) / l, + ("função" == tipo de u? u.apply (isto, argumentos): u)), p = h * ( 0> s? -1: 1), g = ao.sum (c), v = g? (Sl * p) / g: 0, d =ao.range (l), y = []; retorno null! = e && d.sort (e === bl? function (n,t) {return c [t] -c [n]}: function (n, t) {return e (o [n], o [t])}), d.forEach (função (n) {y [n ] = {data: o [n], valor: a = c [n], startAngle: f, endAngle: f + = a * v + p, padAngle: h}}), y} var t = número, e = bl , r = 0, i = Ho, u = 0; retorno n.value = função (e) {return argumentos.length? (t = e, n): t}, n.sort = função (t) {argumentos de retorno () = (e = t, n): e}, n.startAngle = função (t) {return argumentos.length? (r = t, n): r}, n.endAngle = função (t) {argumentos de retorno .length? (i = t, n): i}, n.padAngle = função (t) {retorno arguments.length? (u = t, n): u}, n}; var bl = {}; layout.stack = function () {função n (a, l) {if (! (h = a.length)) retorna a; var c = a.map (função (e, r) {retorno t.call (n , e, r)}), f = c.map (função (t) {retorno t.map (função (t, e) {retorno [u.call (n, t, e), o.call (n, t, e)]})}), s = e.call (n, f, l); c = ao.permute (c, s), f = ao.permute (f, s); var h, p, g, v, d = r.call (n, f, l), y = c [0] .comprimento; para (g = 0; y> g; ++ g) para (i.call (n, c [ 0] [g], v = d [g], f [0] [g] [1]), p = 1; h> p;++ p) i.call (n, c [p] [g], v + = f [p-1] [g] [1], f [p] [g] [1]); retorno a} var = m, e = gi, r = vi, i = pi, u = si, o = hi; retorno n.valores = função (e) {retorno arguments.length? (t = e, n): t}, n .order = function (t) {retorno arguments.length? (e = "function" == tipoof t? t: _l.get (t) || gi, n): e}, n.offset = funç˜ao (t) {return arguments.length? (r = "função" == tipoof t? t: wl.get (t) || vi, n): r}, nx = função (t) {return arguments.length? (u = t, n): u}, ny = função (t) {retorno arguments.length? (o = t, n): o}, n.out = função (t) {return arguments.length? (i = t, n): i}, n}; var _l = ao.map ({"dentro para fora": função (n) {var t, e, r = n.length, i = n.map (di), u = n.map (yi), o = ao.range (r) .sort (função (n, t) {retorno i [n] -i [t]}), a = 0, l = 0, c = [] , f = []; para (t = 0; r> t; ++ t) e = o [t], l> a? (a + = u [e], c.push (e)): (l + = u [e], f.push (e)); retorno f.reverse (). concat (c)}, reverso: function (n) {return ao.range (n.length) .reverse ()}, "padrão ":gi}), wl = ao.map ({silhueta: função (n) {var t, e, r, i = n.length, u = n [0] .comprimento, o = [], a = 0, l = []; para (e = 0; u> e; ++ e) {para (t = 0, r = 0; i> t; t ++) r + = n [t] [e] [1]; a && (a = r), o.push (r)} para (e = 0; u> e; ++ e) l [e] = (ao [e]) / 2; retorno l}, wiggle: function ( n) {var t, e, r, i, u, o, a, l, c, f = n.length, s = n [0], h = s.length, p = []; 0] = l = c = 0, e = 1; h> e; ++ e) {para (t = 0, i = 0; f> t; ++ t) i + = n [t] [e] [ 1]; para (t = 0, u = 0, a = s [e] [0] -s [e-1] [0]; f> t; ++ t) {para (r = 0, o = (n [t] [e] [1] -n [t] [e-1] [1]) / (2 * a); t> r; ++ r) o + = (n [r] [e] [1] -n [r] [e-1] [1]) / a; u + = o * n [t] [e] [1]} p [e] = l- = i? U / i * a : 0, c> l && (c = l)} para (e = 0; h> e; ++ e) p [e] - = c; retorno p}, expanda: function (n) {var t, e, r, i = n.length, u = n [0] .length, o = 1 / i, a = []; para (e = 0; u> e; ++ e) {para (t = 0, r = 0; i> t; t ++) r + = n [t] [e] [1]; se (r) para (t = 0; i> t; t ++) n [t] [e] [1] / = r; senão para (t = 0; i> t; t ++) n [t] [e] [1] = o} para (e = 0; u> e; ++ e) a [e] = 0; a}, zero: vi}); ao.layout.histograma = function () {função n (n, u) {para (var o, a, l = [], c = n.map (e, isto), f = r.call (isto, c, u), s = i.call (isto, f, c, u), u = -1, h = c.length, p = s.length-1, g = t? 1: 1 / h; ++ u <p; ) o = l [u] = [], o.dx = s [u + 1] - (ox = s [u]), oy = 0; se (p> 0) para (u = -1; ++ u <h;) a = c [u], a> = f [0] && a <= f [1] && (o = l [ao.bisect (s, a, 1, p) -1], o. y + = g, o.push (n [u])); retorno l} var t =! 0, e = Número, r = bi, i = Mi; retorno n.valor = função (t) {retorno arguments.length (e = t, n): e}, n.range = função (t) {return argumentos.length? (r = En (t), n): r}, n.bins = função (t) {retorno arguments.length? (i = "numero" == tipo de t? funcao (n) {retorno xi (n, t)}: En (t), n): i}, n.frequencia = funcao (e) {retorno arguments.length? (t = !! e, n): t}, n}, ao.layout.pack = function () {função n (n, u) {var o = e.call (isto, n, u ), a = o [0], l = i [0], c = i [1], f = null == t? Math.sqrt: "funç˜ao" == typeof t? t: funç˜ao () {return t }; se (ax = ay = 0, oi (a, função (n) {nr = + f (n.valor)}), oi (a, Ni), r) {vars = r * (t1: Math.max (2 * ar / l, 2 * ar / c)) / 2; oi (a, função (n) {nr + = s}), oi (a, Ni), oi (a, função (n) {nr- = s})} retorno Ci (a, l / 2, c / 2, t? 1: 1 / Math.max (2 * ar / l, 2 * ar / c)), o} var, e = ao.layout.hierarchy (). Sort (_i), r = 0, i = [1 , 1]; return n.size = function (t) {return argumentos.length? (I = t, n): i}, n.radius = função (e) {return arguments.length? (T = null == e || "function" == typeof e? e: + e, n): t}, n.padding = funç˜ao (t) {return argumentos.length? (r = + t, n): r}, ii ( n, e)}, ao.layout.tree = função () {função n (n, i) {var f = o.call (isto, n, i), s = f [0], h = t (s ); se (oi (h, e), h.parent.m = -hz, ui (h, r), c) ui (s, u); ou {var p = s, g = s, v = s ; ui (s, função (n) {nx <px && (p = n), nx> gx && (g = n), n.depth> v.depth && (v = n)}); var d = a (p, g) / 2-px, y = l [0] / (g.x + a (g, p) / 2 + d), m = l [1] / (v.depth || 1); ui (s , função (n) {nx = (n.x + d) * y, ny = n.depth * m})} return f} função t (n) {para (var t, e = {A: null,children: [n]}, r = [e]; null! = (t = r.pop ());) para (var i, u = t.children, o = 0, a = comprimento.a> o; ++ o) r.push ((u [o] = i = {_: u [o], pai: t, filhos: (i = u [o] .children) && i.slice () || [ ], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: nulo, i: o}). A = i); retorno e.children [0]} e (n) {var = n.children, e = n.parent.children, r = ni? e [ni-1]: null; if (t.length) {Di (n); var u = (t [0] .z + t [t.length-1] .z) / 2; r? (Nz = r.z + a (n ._, r ._), nm = nz-u): nz = u } else r && (nz = r.z + a (n._, r ._)); n.parent.A = i (n, r, n.parent.A || e [0])} função r ( n) {n ._. x = n.z + n.parent.m, n.m + = n.parent.m} função i (n, t, e) {se (t) {para (var r, i = n, u = n, o = t, l = i.parent.children [0], c = im, f = hum, s = om, h = lm; o = Ti (o), i = qi (i ), o && i;) l = qi (l), u = Ti (u), ua = n, r = o.z + si.z-c + a (o._, i ._), r> 0 && ( Ri (Pi (o, n, e), n, r), c + = r, f + = r), s + = om, c + = im, h + = lm, f + = um; o &&! Ti (u) && (ut = o, u.m + = sf), i &&! qi (l) && (lt = i, l.m + = ch,e = n)} return e} função u (n) {nx * = l [0], ny = n.depth * l [1]} var o = ao.layout.hierarchy (). sort (nulo) .valor (null), a = Li, l = [1,1], c = null; retorno n.separation = função (t) {retorno arguments.length? (a = t, n): a}, n.size = function (t) {return argumentos.length? (c = null == (l = t)? u: null, n): c? null: l}, n.nodeSize = function (t) {retornar argumentos.length? (c = null == (l = t)? null: u, n): c? l: null}, ii (n, o)}, ao.layout.cluster = função () {função n (n, u ) {var o, a = t.call (isso, n, u), l = a [0], c = 0; oi (l, funç˜ao (n) {var t = n.children; t && t.length? ( nx = ji (t), ny = Ui (t)): (nx = o? c + = e (n, o): 0, ny = 0, o = n)}); var f = Fi (l), s = Hi (l), h = fx-e (f, s) /2, p = .x + e (s, f) / 2; retorno oi (l, i? função (n) {nx = ( nx-lx) * r [0], ny = (ly-ny) * r [1]}: função (n) {nx = (nx-h) / (ph) * r [0], ny = (1 - (ly ny / ly: 1)) * r [1]}), um} var t = ao.layout.hierarchy (). sort (nulo) .valor (nulo), e = Li, r = [1 , 1], i =! 1; return n.separation = função (t) {argumentos de retorno.comprimento? (e = t, n): e}, n.size = função (t) {retorno arguments.length? (i = null == (r = t), n): i? null: r}, n .nodeSize = function (t) {return argumentos.length? (i = nulo! = (r = t), n): i? r: nulo}, ii (n, t)}, ao.layout.treemap = função () {função n (n, t) {para (var e, r, i = -1, u = n.length; ++ i <u;) r = (e = n [i]). valor * ( 0> t? 0: t), e.area = isNaN (r) || 0> = r? 0: r} funcao t (e) {var u = e.crianças; if (u && u.length) {var , a, l, c = s (e), f = [], h = u.slice (), g = 1/0, v = "fatia" === p? c.dx: "dados" == = p? c.dy: "fatia-dado" === p? 1 & e.depth? c.dy: c.dx: Math.min (c.dx, c.dy); para (n (h, c. dx * c.dy / e.value), f.area = 0; (l = h.length)> 0;) f.push (o = h [l-1]), f.area + = o.area, "squarify"! == p || (a = r (f, v)) <= g? (h.pop (), g = a): (f.area- = f.pop (). área, i (f, v, c,! 1), v = Math.min (c.dx, c.dy), f.length = f.area = 0, g = 1/0); f.length && (i (f , v, c,! 0), f.length = f.area = 0), u.forEach (t)}} function e (t) {var r = t.children;if (r && r.length) {var u, o = s (t), a = r.slice (), l = []; para (n (a, o.dx * o.dy / t.value), l .area = 0; u = a.pop ();) l.push (u), l.area + = u.area, nulo! = uz && (i (l, uz? o.dx: o.dy, o, a.length), l.length = l.area = 0); r.forEach (e)}} function r (n, t) {para (var e, r = n.area, i = 0, u = 1/0, o = -1, a = n.length; ++ o <a;) (e = n [o] .area) && (u> e && (u = e), e> i && (i = e )); return r * = r, t * = t, r Math.max (t * i * g / r, r / (t * u * g)): 1/0} função i (n, t, e, r) {var i, u = -1, o = comprimento n, a = ex, c = ey, f = t 1 (n.area / t): 0;r / (t * u * g)): 1/0} função i (n, t, e, r) {var i, u = -1, o = comprimento n, a = ex, c = ey, f = t? l (narea / t): 0;r / (t * u * g)): 1/0} função i (n, t, e, r) {var i, u = -1, o = comprimento n, a = ex, c = ey, f = t? l (narea / t): 0;
if (t == e.dx) {para ((r || f> e.dy) && (f = e.dy); ++ u <o;) i = n [u], ix = a, iy = c, i.dy = f, a + = i.dx = Math.min (e.x + e.dx-a, f? l (i.area / f): 0); iz =! 0, i. dx + = e.x + e.dx-a, e.y + = f, e.dy- = f} else {para ((r || f> e.dx) && (f = e.dx); ++ u <o;) i = n [u], ix = a, i = c, i.dx = f, c + = i.dy = Math.min (e.y + e.dy-c, f? l ( i.area / f): 0); iz =! 1, i.dy + = e.y + e.dy-c, e.x + = f, e.dx- = f}} função u (r) {var i = o || a (r), u = i [0]; retorno ux = uy = 0, u.valor (u.dx = c [0], u.dy = c [1]): u. dx = u.dy = 0, o && a.revalor (u), n ([u], u.dx * u.dia / u.value), (o? e: t) (u), h && (o = i ), i} var o, a = ao.layout.hierarchy (), l = Math.round, c = [1,1], f = null, s = Oi, h =! 1, p = "squarify", g = .5 * (1 + Math.sqrt (5)); retorno u.size = function (n) {retorno arguments.length? (c = n, u): c}, u.padding = função (n) {função t (t) {var e = n.call (u, t, t.depth); return null == e? Oi (t): Ii (t, "número" == typeof e? [e, e , e, e]: e)} function e (t) {return Ii (t, n)} se (! argumentos.comprimento) return f; var r; return s = null == (f = n)? Oi: "função" == (r = tipoof n)? t: "número" === r? (n = [n, n, n, n], e): e, u}, u.round = função (n) {return argumentos.length? (l = n? Math.round: Number, u): l! = Number}, u .sticky = function (n) {return argumentos.length? (h = n, o = nulo, u): h}, u.ratio = função (n) {retorno arguments.length? (g = n, u): g}, u.mode = função (n) {return argumentos.length? (p = n + "", u): p}, ii (u, a)}, ao.random = {normal: função (n, t ) {var e = arguments.length; return 2> e && (t = 1), 1> e && (n = 0), function () {var e, r, i; do e = 2 * Math.random () - 1, r = 2 * Math.random () - 1, i = e * e + r * r; while (! I || i> 1); retorno n + t * e * Math.sqrt (-2 * Math .log (i) / i)}}, logNormal: function () {var n = ao.random.normal.apply (ao, argumentos); função return () {return Math.exp (n ())}}, bates: function (n) {var t = ao.random.irwinHall (n); função de retorno () {return t () / n}}, irwinHall:function (n) {função return () {para (var t = 0, e = 0; n> e; e ++) t + = Math.random (); retorno t}}}, ao.scale = {}; var Sl = {floor: m, ceil: m}; ao.scale.linear = function () {retornar Wi ([0,1], [0,1], Mr,! 1)}; var kl = {s: 1 , g: 1, p: 1, r: 1, e: 1} ao.scale.log = function () {retorno ru (ao.scale.linear (). domínio ([0,1]), 10, ! 0, [1,10])}; var Nl = ao.format (". 0e"), El = {floor: função (n) {return-Math.ceil (-n)}, ceil: function (n ) {return-Math.floor (-n)}}; ao.scale.pow = function () {retorno iu (ao.scale.linear (), 1, [0,1])}, ao.scale.sqrt = function () {return ao.scale.pow (). expoente (.5)}, ao.scale.ordinal = function () {retorno ou ([], {t: "intervalo", a: [[]] }), ao.scale.category10 = function () {return ao.scale.ordinal (). intervalo (Al)}, ao.scale.category20 = function () {retorno ao.scale.ordinal (). Cl)}, ao.scale.category20b = function () {retorno ao.scale.ordinal (). Intervalo (zl)}, ao.scale.category20c = function () {return ao.scale.ordinal (). intervalo (Ll)}; var Al = [2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175] .map (xn), Cl = [2062260,11454440,16744206,16759672 , 2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725] .map (xn), zl = [3750777,5395619,7040719,10264286, 6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654] .map (xn)13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654] .map (xn)13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654] .map (xn), Ll = [3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081] .map (xn); ao.scale.quantile = function () {retornar au ([], [])}, ao.scale.quantize = function () {retornar lu (0,1, [0,1])}, ao.scale. limiar = função () {retorno cu ([. 5], [0,1])}, ao.scale.identity = function () {return fu ([0,1])}, ao.svg = {}, ao.svg.arc = function () {função n () {var n = Math.max (0, + e.apply (isto, argumentos)), c = Math.max (0, + r.apply (isto, argumentos)), f = o.apply (isto, argumentos) -Io, s = a.apply (isto, argumentos) -Io, h = Math.abs (sf), p = f> s? 0: 1; (n> c && (g = c, c = n, n = g), h> = Oo) retorna t (c, p) + (n t (n, 1-p): "") + "Z" ; var g, v, d, y, m, M, x, b, _, w, S, k, N = 0, E = 0, A = []; se ((y = (+ l.apply) this, arguments) || 0) / 2) && (d = u === ql? Math.sqrt (n * n + c * c): + u.apply (isto, argumentos), p || (E * = -1), c &&(E = tn (d / c * Math.sin (y))), n && (N = tn (d / n * Math.sin (y)))), c) {m = c * Math.cos (f + E), M = c * Math.sin (f + E), x = c * Math.cos (sE), b = c * Math.sin (sE); var C = Math.abs (sf-2 * E) <= Fo? 0: 1; se (E & y yu (m, M, x, b) === p ^ C) {var z = (f + s) / 2; m = c*Mat.cos (z ), M = c * Math.sin (z), x = b = null}} else m = M = 0; se (n) {_ = n * Math.cos (sN), w = n * Math.sin (sN), S = n * Math.cos (f + N), k = n * Math.sin (f + N), var L = Math.abs (f-s + 2 * N) <= Fo? 0 : 1; if (N && yu (_, w, S, k) === 1-p ^ L) {var q = (f + s) / 2; _ = n * Math.cos (q), w = n * Math.sin (q), S = k = null}} else _ = w = 0; se (h> Uo && (g = Math.min (Math.abs (cn) /2,+i.apply (isto, argumentos)))> 001) {v = c> n ^ p? 0: 1; var T = g, R = g; se (Fo> h) {var D = nulo == S? [_, w] : null = [x] [m, M]: Re ([m, M], [S, k], [x, b], [_, w]), P = mD [0], U = MD [ 1], j = xD [0], F = bD [1], H = 1 / Math.sin (Math.acos ((P * j + U * F) / (Math.sqrt (P * P + U *) U) * Math.sqrt (j * j + F * F))) / 2), O = Math.sqrt (D [0] * D [0] + D [1] * D [1]); Math.min (g, (nO) / (H-1)), T = Math.min (g,(cO) / (H + 1)}} se (nulo! = x) {var I = mu (nulo == S? [_, w]: [S, k], [m, M], c, T , p), Y = mu ([x, b], [_, w], c, T, p); g === T? A.push ("M", I [0], "A", T, ",", T, "0 0", v, "", I [1], "A", c, ",", c, "0", 1-p ^ yu (I [1] [0], I [1] [1], Y [1] [0], Y [1] [1]), ",", p "", Y [1], "A", T " , ", T," 0 0, ", v," ", Y [0]): A.push (" M ", I [0]," A ", T,", ", T," 0 1 , ", v," ", Y [0])} mais A.push (" M ", m,", ", M); if (null! = S) {var Z = mu ([m, M] , [S, k], n, -R, p), V = mu ([_, w], null = = x [m, M]: [x, b], n, -R, p); g === R? A.push ("L", V [0], "A", R, ",", R, "0 0", v, "", V [1], "A" , n, ",", n, "0", p ^ yu (V [1] [0], V [1] [1], Z [1] [0], Z [1] [1]), ",", 1-p, "", Z [1], "A", R ", ", R", 0 0, ", v," ", Z [0]): A.push (" L ", V [0]," A ", R,", ", R," 0 0 , ", v," ", Z [0])} mais A.push (" L ", _,", ", w)} mais A.push (" M ", m,", ", M), null! = x && A.push ("A", c, ",", c, "0", C, ",", p "", x, ",", b), A.push ("L" , _, ",", w), null! = S && A.push ("A", n, ",", n, "0", L, ",", 1-p, "", S, ", ", k); retorno A.push (" Z "), A.join (" ")} função t (n, t) {retorno" M0 "+ n +" A "+ n +", "+ n +" 0 1, "+ t +" 0, "+ - n +" A "+ n +", "+ n +" 0 1, "+ t +" 0, "+ n} var e = hu, r = pu, i = su, u = ql, o = gu, a = vu, l = du; retorno n.innerRadius = function (t) {argumentos de retorno.length? (e = En (t), n): e}, n.outerRadius = função (t) {return argumentos.length? (r = En (t), n): r}, n.cornerRadius = função ( t) {return arguments.length? (i = En (t), n): i}, n.padRadius = função (t) {retorno arguments.length? (u = t == ql? ql: En (t) , n): u}, n.startAngle = função (t) {return argumentos.length? (o = En (t), n): o}, n.endAngle = função (t) {return arguments.length? ( a = En (t), n): a}, n.padAngle = function (t) {return argumentos.length? (l = En (t), n): l}, n.centroide = function () {var n = (+ e.apply (isto, argumentos) + + r.apply (isto, argumentos)) / 2, t = (+ o.apply (isto, argumentos) + + a.apply (isto, argumentos)) / 2-Io; return [Math.cos (t) * n, Math.sin (t) * n]}, n}; var ql = "auto"; ao.svg.line = function () {retorno Mu (m )}; var Tl = ao.map ({linear: xu, "linear-fechado": bu, passo: _u, "passo-antes": wu, "passo-apÃ³s": Su, base: zu, "base- open ": Lu", base-fechada ": qu, pacote: Tu, cardeal: Eu,"cardinal-open": ku, "cardinal-fechado": Nu, monótono: Fu}); Tl.forEach (função (n, t) {t.key = n, t.closed = / - fechado $ /. test (n)}); var Rl = [0,2 / 3,1 / 3,0], Dl = [0,1 / 3,2 / 3,0], Pl = [0,1 / 6,2 / 3,1 / 6]; ao.svg.line.radial = function () {var n = Mu (Hu); retorno n.radius = nx, excluir nx, n.angle = ny, excluir ny, n}, wu .reverse = Su, Su.reverse = wu, ao.svg.area = function () {retorno Ou (m)}, ao.svg.area.radial = function () {var n = Ou (Hu); .radius = nx, excluir nx, n.innerRadius = n.x0, excluir n.x0, n.outerRadius = n.x1, excluir n.x1, n.angle = ny, excluir ny, n.startAngle = n.y0 , delete n.y0, n.endAngle = n.y1, delete n.y1, n}, ao.svg.chord = function () {função n (n, a) {var l = t (isto, u, n , a), c = t (isto, o, n, a); retorno "M" + l.p0 + r (lr, l.p1, l.a1-l.a0) + (e (l, c) i (lr, l.p1, lr, l.p0): i (lr, l.p1, cr, c.p0) + r (cr, c.p1, c.a1-c.a0) + i ( cr, c.p1, lr, l.p0)) + "Z"} função t (n, t, e, r) {var i = t.call (n, e, r), u = a.chamada (n, i, r), o = l.call (n, i, r) -Io, f = c.call (n, i, r) -Io; retorno {r: u, a0: o, a1 : f, p0: [u * Math.cos (o), u * Math.sin (o)], p1: [u * Math.cos (f), u * Math.sin (f)]}} função e (n, t) {retorno n.a0 == t.a0 && n.a1 == t.a1} função r (n, t, e) {retorno "A" + n + "," + n + "0" + + ( e> Fo) + ", 1" + t} função i (n, t, e, r) {retorno "Q 0,0" + r} var u = Eu, o = xe, a = Iu, l = gu , c = vu; return n.radius = função (t) {retorno arguments.length? (a = En (t), n): a}, n.source = função (t) {return arguments.length? (u = En (t), n): u}, n.target = função (t) {retorno arguments.length? (O = En (t), n): o}, n.startAngle = função (t) {return arguments.length? (l = En (t), n): l}, n.endAngle = função (t) {return argumentos.length? (c = en (t), n): c}, n}, ao .svg.diagonal = function () {função n (n, i) {var u = t.call (isto, n, i), o = e.call (isto, n, i), a = (u.y + oy) / 2, l = [u, {x: ux, y: a}, {x: ox, y: a}, o]; retorno l = l.map (r), "M" + l [ 0] + "C "+ l [1] +" "+ l [2] +" "+ l [3]} var = Me, e = xe, r = Yu; retorno n.source = function (e) {argumentos de retorno. length? (t = En (e), n): t}, n.target = função (t) {return argumentos.length? (e = En (t), n): e}, n.projeção = função ( t) {return argumentos.length? (r = t, n): r}, n}, ao.svg.diagonal.radial = function () {var n = ao.svg.diagonal (), t = Yu, e = n.projection; return n.projection = função (n) {return argumentos.length? e (Zu (t = n)): t}, n}, ao.svg.symbol = function () {função n (n , r) {return (Ul.get (t.call (isto, n, r)) || $ u) (e.call (isto, n, r))} var = Xu, e = Vu; .type = function (e) {return argumentos.length? (t = En (e), n): t}, n.size = função (t) {retorno arguments.length? (e = En (t), n ): e}, n}; var Ul = ao.map ({círculo: $ u, cruz: função (n) {var = Math.sqrt (n / 5) / 2; retorno "M" + - 3 * t + "," + - t + "H" + - t + "V" + - 3 * t + "H" + t + "V" + - t + "H" + 3 * t + "V"+ t + "H" + t + "V" + 3 * t + "H" + - t + "V" + t + "H" + - 3 * t + "Z"}, diamante: função (n) {var t = Math. sqrt (n / (2 * Fl)), e = t * Fl; retorno "M0" + + t + "L" + e + ", 0 0," + t + "" + -e + ", 0Z"}, quadrado : function (n) {var = Math.sqrt (n) / 2; retorno "M" + - t + "," + - t + "L" + t + "," + - t + "" + t + "," + t + "" + -t + "," + t + "Z"}, "triangulo-baixo": function (n) {var = Math.sqrt (n / jl), e = t * jl / 2; retorno "M0 , "+ e +" L "+ t +", "+ - e +" "+ -t +", "+ - e +" Z "}," triangulo-up ": function (n) {var = Math.sqrt (n / jl), e = t * jl / 2; retorne "M0" + + e + "L" + t + "," + e + "" + -t + "," + e + "Z"}}); ao.svg .symbolTypes = Ul.keys (); var jl = Math.sqrt (3), Fl = Math.tan (30 * Yo); Co.transição = função (n) {para (var t, e, r = Hl || ++ Zl, i = Ku (n), u = [], o = Ol || { time: Date.now (), facilidade: Nr, delay: 0, duração: 250}, a = -1, l = this.length; ++ a <l;) {u.push (t = []); para (var c = este [a], f = -1, s = c.length; ++ f <s;) (e = c [f]) ​​&& Qu (e, f, i, r, o), t .push (e)} retorna Wu (u, i, r)}, co .interrupt = function (n) {retornar this.each (null == n? Il: Bu (Ku (n)))}; var Hl , Ol, Il = Bu (Ku ()), Y1 = [], Z1 = 0, Yl.call = Co.call, Y1.empty = co. Vazio, Yn.node = coodo, Y1.size = Co .size, ao.transition = função (n, t) {retorno n && n.transição? Hl? n.transição (t): n: ao.selection (). transição (n)}, ao.transition.prototype = Yl, Yl.select = function (n) {var t, e, r, i = this.id, u = este.nome do espaço, o = []; n = A (n); para (var a = -1, l = this.length; ++ a <l;) {o.push (t = []); para (var c = isto [a], f = -1, s = c.length; ++ f <s;) (r = c [f]) ​​&& (e = n.call (r, r .__ dados __, f, a))? ("__ dados __" em r && (e .__ dados __ = r .__ dados __), Qu (e, f, eu, eur [u] [i]), t.push (e)): t.push (null)} retornar Wu (o, u, i)}, Yl.selectAll = função (n) {var t, e, r , i, u, o = this.id, a = this.namespace, l = []; n = C (n); para (var c = -1, f = este.length; ++ c <f;) para (var s = isto [c], h = -1, p = s.length; ++ h <p;) se (r = s [h]) {u = r [a] [o], e = n.call (r, r .__ dados __, h, c), l.push (t = []), para (var g = -1, v = e.length; ++ g <v;) (i = e [g]) && Qu (i, g, a, o, u), t.push (i)} retornar Wu (l, a, o)}, Yl.filter = função (n) {var t, e, r , i = []; "function"! = tipoof n && (n = O (n)); para (var u = 0, o = este.length; o> u; u ++) {i.push (t = [] ) para (var e = este [u], a = 0, l = e.length; l> a; a ++) (r = e [a]) && n.call (r, r .__ dados __, a, u) && t.push (r)} retornar Wu (i, this.namespace, this.id)}, Yl.tween = função (n, t) {var e = this.id, r = this.namespace; retorno arguments.length <2? This.node () [r] [e] .tween.get (n): Y (isto, null == t? Função (t) {t [r] [e] .tween.remove (n) }: function (i) {i [r] [e] .tween.set (n, t)})}, Yl.attr = function (n, t) {função e () {this.removeAttribute (a)} função r () {this.removeAttributeNS (a.space, a.local)} função i (n) {retorno nulo == n ? e: (n + = "", function () {var t, e = this.getAttribute (a); retorno e! == n && (t = o (e, n), funcao (n) {this.setAttribute ( a, t (n))})})} função u (n) {retorno nulo = n? r: (n + = "", função () {var t, e = this.getAttributeNS (a.space, a .local); return e! == n && (t = o (e, n), função (n) {this.setAttributeNS (a.space, a.local, t (n))})})} if (argumentos .length <2) {para (t em n) this.attr (t, n [t]); retorne isto} var o = "transformar" == n? $ r: Mr, a = ao.ns.qualify ( n); retorna Ju (isso, "attr." + n, t, a.local? u: i)}, Yl.attrTween = funç˜ao (n, t) {funç˜ao e (n, e) {var r = t .call (isso, n, e, this.getAttribute (i)); retorno r && função (n) {this.setAttribute (i, r (n))}} função r (n, e) {var r = t.call (isto, n, e, this.getAttributeNS (i.space, i.local));return r && function (n) {this.setAttributeNS (i.space, i.local, r (n))}} var i = ao.ns.qualify (n); retorne this.tween ("attr." + n, i .local? r: e)}, Yl.style = função (n, e, r) {função i () {this.style.removeProperty (n)} função u (e) {return null == e? i: (e + = "", function () {var i, u = t (este) .getComputedStyle (this, null) .getPropertyValue (n); retorno u! == e && (i = Senhor (u, e), função ( t) {this.style.setProperty (n, i (t), r)})})} var o = argumentos.length; if (3> o) {if ("string"! = tipoof n) {2> o && (e = ""); para (rn n) this.style (r, n [r], e); retorne isto} r = ""} retornar Ju (isso, "estilo". + n, e, u)}, Yl.styleTween = função (n, e, r) {função i (i, u) {var o = e.call (isto, eu, u, t (isto) .getComputedStyle (isto, nulo). getPropertyValue (n)); return o && function (t) {this.style.setProperty (n, o (t), r)}} retornar argumentos.length <3 && (r = ""), this.tween (" style. "+ n, i)}, Yl.text = função (n) {return Ju (isso," texto ", n, Gu)}, Yl.remove = function () { var n = this.namespace; return this.each ("end.transition", function () {var t; este [n] .count <2 && (t = this.parentNode) && t.removeChild (este)})}, Yl.ease = function (n) {var t = this.id, e = this.namespace; retorno arguments.length <1? This.node () [e] [t] .ease :( "função"! = Typeof n && (n = ao.ease.apply (ao, argumentos)), Y (isso, function (r) {r [e] [t] .ease = n}))}, Yl.delay = function (n) { var t = this.id, e = this.namespace; retorno arguments.length <1? this.node () [e] [t] .delay: Y (isto, "função" == tipo de função n? i, u) {r [e] [t] .delay = + n.call (r, r .__ dados __, i, u)} :( n = + n, função (r) {r [e] [t] .delay = n}))}, Yl.duration = função (n) {var t = this.id, e = this.namespace; retorno arguments.length <1? this.node () [e] [t]. duração: Y (isto"function" == typeof n? function (r, i, u) {r [e] [t] .duration = Math.max (1, n.call (r, r .__ dados __, i, u))}: (n = Math.max (1, n), função (r) {r [e] [t] .duração = n}))}, Yl.each = function (n, t) {var e = this.id , r = this.namespace; if (arguments.length <2) {var i = Ol, u = Hl; tente {Hl = e, Y (isso, função (t, i, u) {Ol = t [r] [e], n.call (t, t .__ dados __, i, u)})} finalmente {Ol = i, Hl = u}} senão Y (isso, função (i) {var u = i [r] [ e]; (u.event || (u.event = ao.dispatch ("start", "end", "interrupt"))). on (n, t)}); retorne isto}, Yl.transition = function () {para (var n, t, e, r, i = this.id, u = ++ Zl, o = this.namespace, a = [], l = 0, c = este.length; c> l; l ++) {a.push (n = []); para (var t = este [l], f = 0, s = t.length; s> f; f ++) (e = t [f]) ​​&& (r = e [o] [i], Qu (e, f, o, u, {tempo: r.time, facilidade: r.ease, atraso: r.delay + r.duration, duração: r.duration} )), n.push (e)} retornar Wu (a, o, u)}, ao.svg.axis = function () {função n (n) {n.each (function () {var n,c = ao.select (this), f = this .__ chart__ || e, s = this .__ gráfico __ = e.copy (), h = null == l? s.ticks? s.ticks.apply (s, a ): s.domain (): l, p = null == t? s.tickFormat? s.tickFormat.apply (s, a): m: t, g = c.selectAll (". tick"). dados ( h, s), v = g.enter (). insert ("g", "domínio"). attr ("classe", "tick"). style ("opacidade", Uo), d = ao.transition (g.exit ()). style ("opacidade", Uo) .remove (), y = ao.transition (g.ordem ()). style ("opacidade", 1), M = Math.max (i , 0) + o, x = Zi (s), b = c.selectAll ("domínio."). Dados ([0]), _ = (b.enter (). Append ("caminho"). Attr ( "classe", "domínio"), ao.transition (b)), v.append ("linha"), v.append ("texto"); var w, S, k, N, E = v.select ( "line"), A = y.select ("linha"), C = g.select ("texto"). texto (p), z = v.select ("texto"), L = y.select (" texto "), q =" top "=== r || "esquerda" === r? -1: 1; if ("inferior" === r || "topo" === r? (n = não, w = "x", k = "y", S = "x2", N = "y2", C.attr ("dy", 0> q? "0em": ". 71em"). style ("âncora de texto", "meio" ), attr ("d", "M" + x [0] + "," + q * u + "V0H" + x [1] + "V" + q * u)) :( n = para, w = "y", k = "x", S = "y2", N = "x2", C.attr ("dy", ". 32em"). style ("âncora de texto", 0> q? "fim": "início"), _. attr ("d", "M" + q * u + "," + x [0] + "H0V" + x [1] + "H" + q * u) ), E.attr (N, q * i), z.attr (k, q * M), A.attr (S, 0) .attr (N, q * i), L.attr (w, 0) .attr (k, q * M), s.rangeBand) {var T = s, R = T.rangeBand () / 2; f = s = função (n) {retorno T (n) + R}} mais f .rangeBand? f = s: d.call (n, s, f); v.call (n, f, s), y.call (n, s,s)})} var t, e = ao.scale.linear (), r = Vl, i = 6, u = 6, o = 3, a = [10], l = nulo; retorno n.scale = função (t) {return arguments.length? (e = t, n): e}, n.orient = função (t) {return arguments.length? (r = t em Xl? t + "": Vl, n): r}, n.ticks = function () {return argumentos.length? (a = co (argumentos), n): a}, n.tickValues ​​= função (t) {retorno arguments.length? (l = t, n ): l}, n.tickFormat = função (e) {return argumentos.length? (t = e, n): t}, n.tickSize = função (t) {var e = argumentos.length; retorno e? i = + t, u = + argumentos [e-1], n): i}, n.innerTickSize = função (t) {retorno arguments.length? (i = + t, n): i}, n.outerTickSize = function (t) {return argumentos.length? (u = + t, n): u}, n.tickPadding = função (t) {retorno arguments.length? (o = + t, n): o}, n .tickSubdivide = function () {return arguments.length && n}, n}; var Vl = "inferior", Xl = {top: 1, direita: 1, inferior: 1, esquerda: 1}; ao.svg.brush = função () {função n (t) {t.each (function () {var t = ao.selecione (este) .style ("pointer-events", "todos"). style ("- webkit-toque-destaque-cor", "rgba (0,0,0,0)"). on ("mousedown. brush ", u) .on (" touchstart.brush ", u), o = t.selectAll (" background "). data ([0]); o.enter (). append (" rect "). ("class", "background"). style ("visibilidade", "oculto"). style ("cursor", "crosshair"), t.selectAll (". extent"). data ([0]). () .append ("rect"). attr ("classe", "extensão"). style ("cursor", "move"); var a = t.selectAll ("redimensionar"). dados (v, m a.exit (). remove (), a.enter (). append ("g"). attr ("classe", função (n) {retornar "redimensionar" + n}). style ("cursor" , função (n) {return $ l [n]}). append ("rect"). attr ("x",function (n) {return / [ew] $ /. teste (n)? - 3: nulo}). attr ("y", função (n) {retorno / ^ [ns] /. teste (n)? - 3: null}). Attr ("width", 6) .attr ("altura", 6) .style ("visibilidade", "oculto"), a.style ("display", n.empty ()? " none ": null); var l, s = ao.transition (t), h = ao.transition (o); c && (l = Zi (c), h.attr (" x ", l [0]). attr ("largura", l [1] -l [0]), r (s)), f && (l = Zi (f), h.attr ("y", l [0]). attr ("altura ", l [1] -l [0]), i (s)), e (s)})} função e (n) {n.selectAll (". redimensionar "). attr (" transformar ", função ( n) {return "translate (" + s [+ / e $ /. teste (n)] + "," + h [+ / ^ s /. teste (n)] + ")"})} função r ( n) {n.select (". extensão"). attr ("x", s [0]), n.selectAll (". extensão, .n> rect, .s> rect"). attr ("largura" , s [1] -s [0])} função i (n) {n.select (". extensão"). attr ("y", h [0]), n.selectAll (". extensão, .e> rect, .w> rect"). attr ("altura", h [1] -h [0])} função u () {função u () {32 == ao.event.keyCode && (C || (M = nulo, L [0] - = s [1], L [1] - = h [1], C = 2), S ())} função v () {32 == ao.event.keyCode && 2 == C && (L [0] + = s [1], L [1] + = h [1], C = 0, S ())} função d () {var n = ao.mouse (b), t =! 1; x && (n [0] + = x [0], n [1 ] + = x [1]), C || (ao.event.altKey? (M || (M = [(s [0] + s [1]) / 2, (h [0] + h [1 ]) / 2]), L [0] = s [+ (n [0] <M [0])], L [1] = h [+ (n [1] <M [1])]): M = null), E & y (n, c, 0) && (r (k), t =! 0), A && y (n, f, 1) && (i (k), t =! 0), t && (e (k), w ({tipo: "pincel", modo: C? "mover": "redimensionar"}))} função y (n, t, e) {var r, i, u = Zi (t), l = u [0], c = u [1], f = L [e], v = eh: s, d = v [1] -v [0]; retorno C && (l- = f, c - = d + f), r = (e? g: p)? Math.max (l, Math.min (c, n [e])): n [e], C? i = (r + = f) + d: (M && (f = Math.max (l, Math.min (c, 2 * M [e] -r))), r> f (i = r, r = f): i = f), v [0 ]! = r || v [1]! = i? (e? a = null: o = null, v [0] = r, v [1] = i,! 0): void 0} função m () {d (), k.style ("ponteiro-eventos", "todos"). selectAll (". redimensionar"). style ("display", n.empty ()? "nenhum": null), ao.select ("body"). style ("cursor", nulo), q.on ("mousemove.brush", nulo) .on ("mouseup.brush", nulo) .on ("touchmove.brush", nulo). on ("touchend.brush", null) .on ("keydown.brush", nulo) .on ("keyup.brush", nulo), z (), w ({tipo: "brushend"})} var M , x, b = isto, _ = ao.select (ao.event.target), w = l.of (b, argumentos), k = ao.select (b), N = _. datum (), E = ! / ^ (n | s) $ /. teste (N) && c, A =! / ^ (e | w) $ /. teste (N) && f, C = _. classed ("extensão"), z = W (b), L = ao.mouse (b), q = ao.select (t (b)). on ("keydown.brush", u) .on ("keyup.brush ", v); if (ao.event.changedTouches? q.on (" touchmove.brush ", d). on (" touchend.brush ", m): q.on (" mousemove.brush ", d) .on ("mouseup.brush", m), k.interrupt (). selectAll ("*"). interrupção (), C) L [0] = s [0] -L [0], L [ 1] = h [0] -L [1]; caso contrário, se (N) {var T = + / w $ /. Teste (N), R = + / ^ n / teste (N); x = [s [1-T] -L [0], h [1-R] -L [1]], L [0] = s [T], L [1] = h [R]} mais ao.event.altKey && (M = L.slice ()); k.style ("ponteiro-eventos", "nenhum"). SelectAll (". Redimensionar"). Style ("display", null), ao.select ("body") .style ("cursor", _. style ("cursor")), w ({tipo: "brushstart"}), d ()} var o, a, l = N (n, "início da pincel", "pincel" , "brushend"), c = nulo, f = nulo, s = [0,0], h = [0,0], p = 0, g = 0, v = Bl [0]; retorno n. event = function (n) {n.each (function () {var n = l.of (isto, argumentos), t = {x: s, y: h, i: o, j: a},e = this .__ chart__ || t; this .__ chart __ = t, Hl? ao.select (this) .transition (). each ("start.brush", function () {o = ei, a = ej, s = ex, h = ey, n ({tipo: "brushstart"})}). tween ("escova: escova", função () {var e = xr (s, tx), r = xr (h, ty); return o = a = null, função (i) {s = tx = e (i), h = ty = r (i), n ({tipo: "escova", modo: "redimensionar"})}}). each ("end.brush", function () {o = ti, a = tj, n ({tipo: "pincel", modo: "redimensionar"}), n ({tipo: "brushend"})}): (n ({type: "brushstart"}), n ({tipo: "pincel", modo: "redimensionar"}), n ({tipo: "brushend"}))})}, nx = função (t) {return arguments.length? (c = t, v = Bl [! c << 1 |! f], n): c}, ny = função (t) {return argumentos.length? (f = t, v = Bl [! C << 1 |! F], n): f}, n.clamp = função (t) {retorno arguments.length? (C && f? (P = !! t [0], g = !! t [1]): c? P = !! t: f && (g = !! t), n): c && f? [p, g]: c? p: f? g: nulo}, n.extente = função (t) {var e, r, i, u, l; retorno arguments.length? (c && (e = t [0], r = t [1], f && (e = e [0], r = r [0]), o = [e, r], c.invert && (e = c (e), r = c (r)), e> r && (l = e, e = r, r = l), e = = s [0] && r == s [1] || (s = [e, r])), f && (i = t [0], u = t [1], c && (i = i [1], u = u [1]), a = [i, u], f.invert && (i = f (i) , u = f (u)), i> u && (l = i, i = u, u = l), i == h [0] && u == h [1] || (h = [i, u] )), n) :( c && (o? (e = o [0], r = o [1]): (e = s [0], r = s [1], c.invert && (e = c. invertido (e), r = c.invert (r)), e> r && (l = e, e = r, r = l))), f && (a? (i = a [0], u = a [ 1]): (i = h [0], u = h [1], f.invert && (i = f.invert (i), u = f.invert (u)), i> u && (l = i, i = u, u = l))), c && f? [[e, i], [r, u]]: c? [e, r]: f && [i, u])}, n.clear = funo ( ) {return n.empty () || (s = [0,0], h = [0,0], o = a = nulo), n}, n.empty = function () {retorno !! c && s [ 0] == s [1] || !! f &&h [0] == h [1]}, ao.rebind (n, l, "on")}; var $ l = {n: "ns-resize" e: "ew-resize", s: " ns-resize ", w:" ew-resize ", nw:" nwse-resize ", ne:" nesw-resize ", se:" nwse-resize ", sw:" nesw-resize "}, Bl = [[ "n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s "], []], W1 = forma de fórmula = xa.formato, J, = Wl.utc, Gl = Jl ("% Y-% m-% dT% H:% M:% S.% LZ "); Wl.iso = Date.prototype.toISOString && + new Date ("2000-01-01T00: 00: 00.000Z")? Eo: Gl, eo.parse = função (n) {var t = new Data (n); retorno isNaN (t)? null: t}, eo.toString = Gl.toString, ga.second = On (função (n) {return new va (1e3 * Math.floor (n / 1e3))}, função (n, t) {n.setTime (n.getTime () + 1e3 * Math.floor (t))}, função (n) {return n.getSeconds ()}),ga.seconds = ga.second.range, ga.seconds.utc = ga.second.utc.range, ga.minute = Ativado (função (n) {return new va (6e4 * Math.floor (n / 6e4)) }, function (n, t) {n.setTime (n.getTime () + 6e4 * Math.floor (t))}, função (n) {return n.getMinutes ()}), ga.minutes = ga. minute.range, ga.minutes.utc = ga.minute.utc.range, ga.hour = On (função (n) {var t = n.getTimezoneOffset () / 60; return new va (36e5 * (Math.floor) (n / 36e5-t) + t))}, função (n, t) {n.setTime (n.getTime () + 36e5 * Math.floor (t))}, função (n) {return n.getHours ()}), ga.hours = ga.hour.range, ga.hours.utc = ga.hour.utc.range, ga.mês = On (função (n) {return n = ga.day (n), n.setDate (1), n}, função (n, t) {n.setMonth (n.getMonth () + t)}, função (n) {return n.getMonth ()}), ga.months = ga .month.range, ga.months.utc = ga.month.utc.range; var Kl = [1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5 , 6048e5,2592e6,7776e6,31536e6], Ql ​​= [[ga.second, 1], [ga.second, 5],[ga.second, 15], [ga.second, 30], [ga.minute, 1], [ga.minute, 5], [ga.minute, 15], [ga.minute, 30], [ga .hora, 1], [ga.hour, 3], [ga.hour, 6], [ga.hour, 12], [ga.day, 1], [ga.day, 2], [ga.week , 1], [ga.month, 1], [ga.month, 3], [ga.ano, 1]], nc = Wl.multi ([[".% L", função (n) {return n .getMilliseconds ()}], [":% S", função (n) {return n.getSeconds ()}], ["% I:% M", função (n) {return n.getMinutes ()}] , ["% I% p", função (n) {retorno n.getHours ()}], ["% a% d", função (n) {retorno n.getDay () && 1! = N.getDate () }], ["% b% d", função (n) {return 1! = n.getDate ()}], ["% B", função (n) {return n.getMonth ()}], [" % Y ", zt]]), tc = {intervalo: função (n, t, e) {retorno ao.range (Math.ceil (n / e) * e, + t, e) .map (io)} , floor: m, ceil: m}; Ql.ano = ga.ano, ga.scale = function () {retorno ro (ao.scale.linear (), Ql, nc)}; var ec = Ql.map ( função (n) {return [n [0] .utc, n [1]]}),rc = Jl.multi ([[".% L", função (n) {return n.getUTCMilliseconds ()}], [":% S", função (n) {return n.getUTCSeconds ()}], [ "% I:% M", função (n) {return n.getUTCMinutes ()}], ["% I% p", função (n) {return n.getUTCHours ()}], ["% a% d ", function (n) {return n.getUTCDay () && 1! = n.getUTCDate ()}], ["% b% d ", função (n) {retorno 1! = n.getUTCDate ()}], [ "% B", função (n) {return n.getUTCMonth ()}], ["% Y", zt]]); ec.ano = ga.ano.utc, ga.scale.utc = function () { return ro (ao.scale.linear (), ec, rc)}, ao.text = Uma função (n) {return n.responseText}), ao.json = função (n, t) {return Cn (n , "application / json", uo, t)}, ao.html = function (n, t) {retornar Cn (n, "texto / html", oo, t)}, ao.xml = An (função (n ) {return n.responseXML}), "function" == typeof define && define.amd? (this.d3 = ao, define (ao)): "objeto "== typeof module && module.exports? module.exports = ao: this.d3 = ao} ();
